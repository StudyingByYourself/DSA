{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u4e00. \u4ecb\u7ecd"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"Commands"},{"location":"BuyAndSellStock/","text":"\u4e70\u80a1\u7968\u95ee\u9898 \u00b6 Best Time to Buy and Sell Stock 149 \u00b6 \u65b9\u6cd5\u4e00\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n 2 ) \u00b6 \u4e24\u6b21for\u5faa\u73af\uff0c\u7b2c\u4e00\u5c42\u5faa\u73af\u5bfb\u627e\u4e70\u5165\u4ef7\uff0c\u7b2c\u4e8c\u5c42\u5faa\u73af\u5bfb\u627e\u5356\u51fa\u4ef7 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ for ( int j = i + 1 ; j < n ; j ++) { if ( prices [ j ] - prices [ i ] > profit ){ profit = prices [ j ] - prices [ i ]; } } } return profit ; } } \u65b9\u6cd5\u4e8c\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) \u00b6 \u4e00\u6b21for\u5faa\u73af\uff0cmin\u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5c0f\u503c\uff0cprofit\u8bb0\u5f55\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u83b7\u76ca\u3002 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; int min = prices [ 0 ]; for ( int i = 1 ; i < n ; i ++){ min = Math . min ( min , prices [ i ]); profit = Math . max ( profit , prices [ i ] - min ); } return profit ; } } Best Time to Buy and Sell Stock II 150 \u00b6 \u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) \u4e00\u6b21for\u5faa\u73af\uff0cprofit\u7d2f\u52a0\u4e0a\u76f8\u90bb\u4e24\u6b21\u80a1\u7968\u5dee\u4e3a\u6b63\u6570\u7684\u6536\u76ca Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ){ return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ if ( prices [ i + 1 ] - prices [ i ] > 0 ){ profit += prices [ i + 1 ] - prices [ i ]; } } return profit ; } } Best Time to Buy and Sell Stock III 151 \u00b6 \u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) f[i][j]\u8868\u793a\u524di\u5929\u5728j\u72b6\u6001\u7684\u6700\u5927\u6536\u76ca(eg:\u524d1\u5929\u7684\u4e0b\u6807\u4e3a0) \u5f53\u5904\u4e8e\u975e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j] = max{f[i-1][j], f[i-1][j-1] + A[i-1] \u2013 A[i-2]} \u5f53\u5904\u4e8e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j]=max{f[i-1][j-1], f[i-1][j]+A[i-1]\u2013A[i-2], f[i-1][j-2]+A[i-1]\u2013A[i-2]} Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ n + 1 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } } \u5bf9\u7a7a\u95f4\u8fdb\u884c\u4f18\u5316:\u7a7a\u95f4\u590d\u6742\u5ea6O(1) Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ 2 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } int old = 0 ; int now = 1 ; for ( int i = 1 ; i < n + 1 ; i ++) { old = now ; now = 1 - now ; for ( int j = 1 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j ]; if ( i > 1 && j > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 1 ]+ A [ i - 1 ]- A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j - 1 ]; if ( i > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j ]+ A [ i - 1 ]- A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 2 ]+ A [ i - 1 ]- A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ now ][ j ] > profit ) { profit = f [ now ][ j ]; } } return profit ; } } Best Time to Buy and Sell Stock IV 393 \u00b6 Java\u7248 public class Solution { /** * @param K: An integer * @param prices: An integer array * @return: Maximum profit */ public int maxProfit ( int K , int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } if ( K > n / 2 ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++) { if ( A [ i + 1 ] > A [ i ]) { res += A [ i + 1 ] - A [ i ]; } } return res ; } int [][] f = new int [ n + 1 ][ 2 * K + 1 + 1 ]; for ( int j = 0 ; j < 2 * K + 2 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } }","title":"2.1 Best Time to Buy and Sell Stock"},{"location":"BuyAndSellStock/#_1","text":"","title":"\u4e70\u80a1\u7968\u95ee\u9898"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-149","text":"","title":"Best Time to Buy and Sell Stock 149"},{"location":"BuyAndSellStock/#on2","text":"\u4e24\u6b21for\u5faa\u73af\uff0c\u7b2c\u4e00\u5c42\u5faa\u73af\u5bfb\u627e\u4e70\u5165\u4ef7\uff0c\u7b2c\u4e8c\u5c42\u5faa\u73af\u5bfb\u627e\u5356\u51fa\u4ef7 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ for ( int j = i + 1 ; j < n ; j ++) { if ( prices [ j ] - prices [ i ] > profit ){ profit = prices [ j ] - prices [ i ]; } } } return profit ; } }","title":"\u65b9\u6cd5\u4e00\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n2)"},{"location":"BuyAndSellStock/#on","text":"\u4e00\u6b21for\u5faa\u73af\uff0cmin\u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5c0f\u503c\uff0cprofit\u8bb0\u5f55\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u83b7\u76ca\u3002 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; int min = prices [ 0 ]; for ( int i = 1 ; i < n ; i ++){ min = Math . min ( min , prices [ i ]); profit = Math . max ( profit , prices [ i ] - min ); } return profit ; } }","title":"\u65b9\u6cd5\u4e8c\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n)"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-ii-150","text":"\u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) \u4e00\u6b21for\u5faa\u73af\uff0cprofit\u7d2f\u52a0\u4e0a\u76f8\u90bb\u4e24\u6b21\u80a1\u7968\u5dee\u4e3a\u6b63\u6570\u7684\u6536\u76ca Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ){ return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ if ( prices [ i + 1 ] - prices [ i ] > 0 ){ profit += prices [ i + 1 ] - prices [ i ]; } } return profit ; } }","title":"Best Time to Buy and Sell Stock II 150"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-iii-151","text":"\u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) f[i][j]\u8868\u793a\u524di\u5929\u5728j\u72b6\u6001\u7684\u6700\u5927\u6536\u76ca(eg:\u524d1\u5929\u7684\u4e0b\u6807\u4e3a0) \u5f53\u5904\u4e8e\u975e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j] = max{f[i-1][j], f[i-1][j-1] + A[i-1] \u2013 A[i-2]} \u5f53\u5904\u4e8e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j]=max{f[i-1][j-1], f[i-1][j]+A[i-1]\u2013A[i-2], f[i-1][j-2]+A[i-1]\u2013A[i-2]} Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ n + 1 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } } \u5bf9\u7a7a\u95f4\u8fdb\u884c\u4f18\u5316:\u7a7a\u95f4\u590d\u6742\u5ea6O(1) Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ 2 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } int old = 0 ; int now = 1 ; for ( int i = 1 ; i < n + 1 ; i ++) { old = now ; now = 1 - now ; for ( int j = 1 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j ]; if ( i > 1 && j > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 1 ]+ A [ i - 1 ]- A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j - 1 ]; if ( i > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j ]+ A [ i - 1 ]- A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 2 ]+ A [ i - 1 ]- A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ now ][ j ] > profit ) { profit = f [ now ][ j ]; } } return profit ; } }","title":"Best Time to Buy and Sell Stock III 151"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-iv-393","text":"Java\u7248 public class Solution { /** * @param K: An integer * @param prices: An integer array * @return: Maximum profit */ public int maxProfit ( int K , int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } if ( K > n / 2 ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++) { if ( A [ i + 1 ] > A [ i ]) { res += A [ i + 1 ] - A [ i ]; } } return res ; } int [][] f = new int [ n + 1 ][ 2 * K + 1 + 1 ]; for ( int j = 0 ; j < 2 * K + 2 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } }","title":"Best Time to Buy and Sell Stock IV 393"},{"location":"backpack/","text":"Backpack \u00b6 \u80cc\u5305\u95ee\u9898\u53c2\u8003 \u80cc\u5305\u95ee\u9898\u80cc\u666f\uff1a\u5728\u4e00\u5b9a\u5bb9\u91cf\u7684\u80cc\u5305\u4e2d\u88c5\u5165\u542b\u6709\u4e0d\u540c\u5bb9\u91cf\u548c\u4ef7\u503c\u7684\u7269\u54c1 ( https://blog.csdn.net/ppp_1026hc/article/details/52138025 ) 0-1\u80cc\u5305 \u00b6 Backpack 92 \u00b6 f[i][j] means whether the former i number can make up j. f[i][j] = f[i-1][j] || (f[i-1][j-A[i-1]] | j-A[i-1] >= 0) \u4ee3\u7801\u5b9e\u73b0 public class Backpack { public int backPack ( int m , int [] A ) { int n = A . length ; if ( n == 0 ) { return 0 ; } boolean [][] f = new boolean [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ 0 ][ j ] = false ; } for ( int i = 1 ; i < n + 1 ; i ++) { f [ i ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 ) { f [ i ][ j ] = f [ i ][ j ] || f [ i - 1 ][ j - A [ i - 1 ]]; } } } for ( int j = m ; j >= 0 ; j --) { if ( f [ n ][ j ]) { return j ; } } return 0 ; } } BackpackII 125 \u00b6 f[i][j] means the maximum value of the former i number making up j. f[i][j] = max{f[i-1][j], f[i-1][j-A[i-1]] + V[i-1] | j-A[i-1] >= 0} \u4ee3\u7801\u5b9e\u73b0 public class BackpackII { public int backPackII ( int m , int [] A , int [] V ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [][] f = new int [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ 0 ][ j ] = - 1 ; } for ( int i = 1 ; i < n + 1 ; i ++){ f [ i ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 && f [ i - 1 ][ j - A [ i - 1 ]] != - 1 ){ f [ i ][ j ]= Math . max ( f [ i ][ j ], f [ i - 1 ][ j - A [ i - 1 ]]+ V [ i - 1 ]); } } } int res = 0 ; for ( int j = 0 ; j < m + 1 ; j ++){ res = Math . max ( res , f [ n ][ j ]); } return res ; } } \u5b8c\u5168\u80cc\u5305 \u00b6 BackpackIII 440 \u00b6 f[i] means the maximum value of size i, if f[i] doen't exist,using Integer.MIN_VALUE to represent it. f[i] = max{f[i-A[j]] + V[j]} \u4ee3\u7801\u5b9e\u73b0 public class BackpackIII { public int backPackIII ( int [] A , int [] V , int m ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [] f = new int [ m + 1 ]; f [ 0 ] = 0 ; for ( int i = 1 ; i < m + 1 ; i ++){ f [ i ] = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++){ if ( i - A [ j ] >= 0 && f [ i - A [ j ]] + V [ j ] > f [ i ]){ f [ i ] = f [ i - A [ j ]] + V [ j ]; } } } int res = 0 ; for ( int i = 0 ; i < m + 1 ; i ++){ res = Math . max ( res , f [ i ]); } return res ; } }","title":"1. backpack"},{"location":"backpack/#backpack","text":"\u80cc\u5305\u95ee\u9898\u53c2\u8003 \u80cc\u5305\u95ee\u9898\u80cc\u666f\uff1a\u5728\u4e00\u5b9a\u5bb9\u91cf\u7684\u80cc\u5305\u4e2d\u88c5\u5165\u542b\u6709\u4e0d\u540c\u5bb9\u91cf\u548c\u4ef7\u503c\u7684\u7269\u54c1 ( https://blog.csdn.net/ppp_1026hc/article/details/52138025 )","title":"Backpack"},{"location":"backpack/#0-1","text":"","title":"0-1\u80cc\u5305"},{"location":"backpack/#backpack-92","text":"f[i][j] means whether the former i number can make up j. f[i][j] = f[i-1][j] || (f[i-1][j-A[i-1]] | j-A[i-1] >= 0) \u4ee3\u7801\u5b9e\u73b0 public class Backpack { public int backPack ( int m , int [] A ) { int n = A . length ; if ( n == 0 ) { return 0 ; } boolean [][] f = new boolean [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ 0 ][ j ] = false ; } for ( int i = 1 ; i < n + 1 ; i ++) { f [ i ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 ) { f [ i ][ j ] = f [ i ][ j ] || f [ i - 1 ][ j - A [ i - 1 ]]; } } } for ( int j = m ; j >= 0 ; j --) { if ( f [ n ][ j ]) { return j ; } } return 0 ; } }","title":"Backpack 92"},{"location":"backpack/#backpackii-125","text":"f[i][j] means the maximum value of the former i number making up j. f[i][j] = max{f[i-1][j], f[i-1][j-A[i-1]] + V[i-1] | j-A[i-1] >= 0} \u4ee3\u7801\u5b9e\u73b0 public class BackpackII { public int backPackII ( int m , int [] A , int [] V ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [][] f = new int [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ 0 ][ j ] = - 1 ; } for ( int i = 1 ; i < n + 1 ; i ++){ f [ i ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 && f [ i - 1 ][ j - A [ i - 1 ]] != - 1 ){ f [ i ][ j ]= Math . max ( f [ i ][ j ], f [ i - 1 ][ j - A [ i - 1 ]]+ V [ i - 1 ]); } } } int res = 0 ; for ( int j = 0 ; j < m + 1 ; j ++){ res = Math . max ( res , f [ n ][ j ]); } return res ; } }","title":"BackpackII 125"},{"location":"backpack/#_1","text":"","title":"\u5b8c\u5168\u80cc\u5305"},{"location":"backpack/#backpackiii-440","text":"f[i] means the maximum value of size i, if f[i] doen't exist,using Integer.MIN_VALUE to represent it. f[i] = max{f[i-A[j]] + V[j]} \u4ee3\u7801\u5b9e\u73b0 public class BackpackIII { public int backPackIII ( int [] A , int [] V , int m ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [] f = new int [ m + 1 ]; f [ 0 ] = 0 ; for ( int i = 1 ; i < m + 1 ; i ++){ f [ i ] = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++){ if ( i - A [ j ] >= 0 && f [ i - A [ j ]] + V [ j ] > f [ i ]){ f [ i ] = f [ i - A [ j ]] + V [ j ]; } } } int res = 0 ; for ( int i = 0 ; i < m + 1 ; i ++){ res = Math . max ( res , f [ i ]); } return res ; } }","title":"BackpackIII 440"},{"location":"quickSort/","text":"QuickSort \u00b6 \u5feb\u901f\u6392\u5e8f\u53c2\u8003 ( http://developer.51cto.com/art/201403/430986.htm ) \u4e00\u822c\u7684\u5feb\u901f\u6392\u5e8f \u00b6 \u5047\u8bbe\u6211\u4eec\u73b0\u5728\u5bf9\u201c6 1 2 7 9 3 4 5 10 8\u201d\u8fd9\u4e2a10\u4e2a\u6570\u8fdb\u884c\u6392\u5e8f\u3002\u9996\u5148\u4ee5\u7b2c\u4e00\u4e2a\u65706\u4f5c\u4e3a\u57fa\u51c6\u6570\u5427\u3002\u63a5\u4e0b\u6765\uff0c\u9700\u8981\u5c06\u8fd9\u4e2a\u5e8f\u5217\u4e2d\u6240\u6709\u6bd4\u57fa\u51c6\u6570\u5927\u7684\u6570\u653e\u57286\u7684\u53f3\u8fb9\uff0c\u6bd4\u57fa\u51c6\u6570\u5c0f\u7684\u6570\u653e\u57286\u7684\u5de6\u8fb9\uff0c\u7c7b\u4f3c\u4e0b\u9762\u8fd9\u79cd\u6392\u5217\uff1a 3 1 2 5 4 6 9 7 10 8 \u5b9e\u73b0\u4ee3\u7801 public class QuickSort { public static void sort2 ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } if ( i < j ) { swap ( arr , i , j ); } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } if ( i < j ) { swap ( arr , i , j ); } } sort2 ( arr , lo , i - 1 ); sort2 ( arr , i + 1 , hi ); } public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Object [] arr , int i , int j ) { Object t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } } \u968f\u673a\u5316\u5feb\u901f\u6392\u5e8f \u00b6 \u5982\u679c\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u662f\u8fd1\u4e4e\u6709\u5e8f\u7684\uff0c\u8fd9\u65f6\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c06\u9000\u5316\u6210O(n 2 )\uff0c\u4e3a\u4e86\u7ef4\u6301O(nlogn)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u9700\u8981\u6539\u53d8\u9009\u62e9\u7684\u57fa\u51c6(sentinel)\uff0c\u53d6\u5176\u968f\u673a\u4e00\u4e2a\u6570\u4e3a\u57fa\u51c6\u3002 \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort2 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } } \u4e09\u8def\u5feb\u901f\u6392\u5e8f \u00b6 \u7136\u800c\u5f53\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u4e2d\u5b58\u5728\u5927\u91cf\u91cd\u590d\u5143\u7d20\u65f6\uff0c\u5219\u9700\u8981\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 \u52a8\u753b\u6f14\u793a \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort3 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int lt = lo ; int gt = hi + 1 ; int i = lo + 1 ; while ( i < gt ) { if ( arr [ i ]. compareTo ( sentinel ) < 0 ) { swap ( arr , i , lt + 1 ); i ++; lt ++; } else if ( arr [ i ]. compareTo ( sentinel ) > 0 ) { swap ( arr , i , gt - 1 ); gt --; } else { i ++; } } swap ( arr , lo , lt ); sort ( arr , lo , lt - 1 ); sort ( arr , gt , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } public static void main ( String [] args ) { int n = 1000000 ; Comparable [] arr = new Comparable [ n ]; for ( int i = 0 ; i < n ; i ++) { arr [ i ] = i / 100000 ; } long startTime = System . nanoTime (); sort ( arr , 0 , arr . length - 1 ); long endTime = System . nanoTime (); System . out . println (( endTime - startTime ) / 1000000000.0 + \" s\" ); } } MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u4e8c. QuickSort"},{"location":"quickSort/#quicksort","text":"\u5feb\u901f\u6392\u5e8f\u53c2\u8003 ( http://developer.51cto.com/art/201403/430986.htm )","title":"QuickSort"},{"location":"quickSort/#_1","text":"\u5047\u8bbe\u6211\u4eec\u73b0\u5728\u5bf9\u201c6 1 2 7 9 3 4 5 10 8\u201d\u8fd9\u4e2a10\u4e2a\u6570\u8fdb\u884c\u6392\u5e8f\u3002\u9996\u5148\u4ee5\u7b2c\u4e00\u4e2a\u65706\u4f5c\u4e3a\u57fa\u51c6\u6570\u5427\u3002\u63a5\u4e0b\u6765\uff0c\u9700\u8981\u5c06\u8fd9\u4e2a\u5e8f\u5217\u4e2d\u6240\u6709\u6bd4\u57fa\u51c6\u6570\u5927\u7684\u6570\u653e\u57286\u7684\u53f3\u8fb9\uff0c\u6bd4\u57fa\u51c6\u6570\u5c0f\u7684\u6570\u653e\u57286\u7684\u5de6\u8fb9\uff0c\u7c7b\u4f3c\u4e0b\u9762\u8fd9\u79cd\u6392\u5217\uff1a 3 1 2 5 4 6 9 7 10 8 \u5b9e\u73b0\u4ee3\u7801 public class QuickSort { public static void sort2 ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } if ( i < j ) { swap ( arr , i , j ); } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } if ( i < j ) { swap ( arr , i , j ); } } sort2 ( arr , lo , i - 1 ); sort2 ( arr , i + 1 , hi ); } public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Object [] arr , int i , int j ) { Object t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } }","title":"\u4e00\u822c\u7684\u5feb\u901f\u6392\u5e8f"},{"location":"quickSort/#_2","text":"\u5982\u679c\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u662f\u8fd1\u4e4e\u6709\u5e8f\u7684\uff0c\u8fd9\u65f6\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c06\u9000\u5316\u6210O(n 2 )\uff0c\u4e3a\u4e86\u7ef4\u6301O(nlogn)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u9700\u8981\u6539\u53d8\u9009\u62e9\u7684\u57fa\u51c6(sentinel)\uff0c\u53d6\u5176\u968f\u673a\u4e00\u4e2a\u6570\u4e3a\u57fa\u51c6\u3002 \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort2 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } }","title":"\u968f\u673a\u5316\u5feb\u901f\u6392\u5e8f"},{"location":"quickSort/#_3","text":"\u7136\u800c\u5f53\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u4e2d\u5b58\u5728\u5927\u91cf\u91cd\u590d\u5143\u7d20\u65f6\uff0c\u5219\u9700\u8981\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 \u52a8\u753b\u6f14\u793a \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort3 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int lt = lo ; int gt = hi + 1 ; int i = lo + 1 ; while ( i < gt ) { if ( arr [ i ]. compareTo ( sentinel ) < 0 ) { swap ( arr , i , lt + 1 ); i ++; lt ++; } else if ( arr [ i ]. compareTo ( sentinel ) > 0 ) { swap ( arr , i , gt - 1 ); gt --; } else { i ++; } } swap ( arr , lo , lt ); sort ( arr , lo , lt - 1 ); sort ( arr , gt , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } public static void main ( String [] args ) { int n = 1000000 ; Comparable [] arr = new Comparable [ n ]; for ( int i = 0 ; i < n ; i ++) { arr [ i ] = i / 100000 ; } long startTime = System . nanoTime (); sort ( arr , 0 , arr . length - 1 ); long endTime = System . nanoTime (); System . out . println (( endTime - startTime ) / 1000000000.0 + \" s\" ); } } MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u4e09\u8def\u5feb\u901f\u6392\u5e8f"},{"location":"BinaryTree/AVLTree/","text":"6.AVL\u6811 \u00b6 6.1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb \u00b6 6.1.1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u89c4\u5219 \u00b6 6.1.2 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u5b9e\u4f8b \u00b6 \u5907\u6ce8\uff1a\u5728\u5de6\u65cb\u548c\u53f3\u65cb\u65f6\u9700\u8981\u91cd\u65b0\u8ba1\u7b97height\u503c 6.2 AVL\u6811\u7684\u6574\u4f53\u4ee3\u7801 \u00b6 Java\u7248 import java.util.Queue ; import java.util.List ; import java.util.ArrayList ; import java.util.LinkedList ; public class AVLTree < K extends Comparable < K >, V > { private class Node { public K key ; public V value ; public Node left ; public Node right ; public int height ; public Node ( K key , V value ) { this . key = key ; this . value = value ; this . left = null ; this . right = null ; this . height = 1 ; } } private Node root ; private int size ; public AVLTree () { root = null ; size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } // \u8ba1\u7b97\u9ad8\u5ea6 public int getHeight ( Node node ) { if ( node == null ) { return 0 ; } return node . height ; } // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 private int getBalanceFactor ( Node node ) { if ( node == null ) { return 0 ; } return getHeight ( node . left ) - getHeight ( node . right ); } // \u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u641c\u7d22\u6811 public boolean isBST () { List < K > keys = new ArrayList <>(); inOrder ( root , keys ); for ( int i = 1 ; i < keys . size (); i ++) { if ( keys . get ( i ). compareTo ( keys . get ( i - 1 )) < 0 ) { return false ; } } return true ; } private void inOrder ( Node node , List < K > keys ) { if ( node == null ) { return ; } inOrder ( node . left , keys ); keys . add ( node . key ); inOrder ( node . right , keys ); } // \u5224\u65ad\u662f\u5426\u4e3a\u5e73\u8861\u4e8c\u53c9\u6811 public boolean isBalanced () { return isBalanced ( root ); } private boolean isBalanced ( Node node ) { if ( node == null ) { return true ; } int balanceFactor = getBalanceFactor ( node ); if ( Math . abs ( balanceFactor ) > 1 ) { return false ; } return isBalanced ( node . left ) && isBalanced ( node . right ); } private Node getNode ( Node node , K key ) { if ( node == null ) { return null ; } if ( key . compareTo ( node . key ) < 0 ) { return getNode ( node . left , key ); } else if ( key . compareTo ( node . key ) > 0 ) { return getNode ( node . right , key ); } else { return node ; } } public boolean contains ( K key ) { return getNode ( root , key ) != null ; } public void preOrder () { preOrder ( root ); } private void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . key ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder () { inOrder ( root ); } private void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . key ); inOrder ( node . right ); } public void postOrder () { postOrder ( root ); } private void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . key ); } public void levelOrder () { Queue < Node > q = new LinkedList <>(); q . add ( root ); while (! q . isEmpty ()) { Node cur = q . remove (); System . out . println ( cur . key ); if ( cur . left != null ) { q . add ( cur . left ); } if ( cur . right != null ) { q . add ( cur . right ); } } } public V get ( K key ) { Node node = getNode ( root , key ); return node == null ? null : node . value ; } public void set ( K key , V newValue ) { Node node = getNode ( root , key ); if ( node == null ) { throw new IllegalArgumentException ( key + \"doesn't exist!\" ); } node . value = newValue ; } // \u53f3\u65cb // y x // / \\ / \\ // x T4 \u5411\u53f3\u65cb\u8f6c(y) z y // / \\ - - - - - - -> / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate ( Node y ) { Node x = y . left ; Node T3 = x . right ; x . right = y ; y . left = T3 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } // \u5de6\u65cb // y x // / \\ / \\ // T1 x \u5411\u5de6\u65cb\u8f6c(y) y z // / \\ - - - - - - -> / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate ( Node y ) { Node x = y . right ; Node T2 = x . left ; x . left = y ; y . right = T2 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } public void add ( K key , V value ) { root = add ( root , key , value ); } private Node add ( Node node , K key , V value ) { if ( node == null ) { size ++; return new Node ( key , value ); } if ( key . compareTo ( node . key ) < 0 ) { node . left = add ( node . left , key , value ); } if ( key . compareTo ( node . key ) > 0 ) { node . right = add ( node . right , key , value ); } else { node . value = value ; } // \u8ba1\u7b97\u9ad8\u5ea6 node . height = 1 + Math . max ( getHeight ( node . left ), getHeight ( node . right )); // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 int balanceFactor = getBalanceFactor ( node ); // LL if ( balanceFactor > 1 && getBalanceFactor ( node . left ) >= 0 ) { return rightRotate ( node ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) <= 0 ) { return leftRotate ( node ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( node . left ) < 0 ) { node . left = leftRotate ( node . left ); return rightRotate ( node ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) > 0 ) { node . right = rightRotate ( node . right ); return leftRotate ( node ); } return node ; } public K findMin () { if ( size == 0 ) { throw new IllegalArgumentException ( \"Can not find something from a blank tree.\" ); } return findMin ( root ). key ; } private Node findMin ( Node node ) { if ( node . left == null ) { return node ; } return findMin ( node . left ); } public K removeMin () { K ret = findMin (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public void remove ( K key ) { root = remove ( root , key ); } private Node remove ( Node node , K key ) { if ( node == null ) { return null ; } Node retNode ; if ( key . compareTo ( node . key ) < 0 ) { node . left = remove ( node . left , key ); retNode = node ; } else if ( key . compareTo ( node . key ) > 0 ) { node . right = remove ( node . right , key ); retNode = node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; retNode = rightNode ; } else if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; retNode = leftNode ; } else { Node successor = findMin ( node . right ); // successor.right = removeMin(node.right); successor . right = remove ( node . right , successor . key ); successor . left = node . left ; node . left = node . right = null ; retNode = successor ; } } if ( retNode == null ) { return null ; } retNode . height = 1 + Math . max ( getHeight ( retNode . left ), getHeight ( retNode . right )); int balanceFactor = getBalanceFactor ( retNode ); // LL if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) >= 0 ) { return rightRotate ( retNode ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) <= 0 ) { return leftRotate ( retNode ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) < 0 ) { retNode . left = leftRotate ( retNode . left ); return rightRotate ( retNode ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) > 0 ) { retNode . right = rightRotate ( retNode . right ); return leftRotate ( retNode ); } return retNode ; } }","title":"3. avlTree"},{"location":"BinaryTree/AVLTree/#6avl","text":"","title":"6.AVL\u6811"},{"location":"BinaryTree/AVLTree/#61-avl","text":"","title":"6.1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb"},{"location":"BinaryTree/AVLTree/#611-avl","text":"","title":"6.1.1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u89c4\u5219"},{"location":"BinaryTree/AVLTree/#612-avl","text":"\u5907\u6ce8\uff1a\u5728\u5de6\u65cb\u548c\u53f3\u65cb\u65f6\u9700\u8981\u91cd\u65b0\u8ba1\u7b97height\u503c","title":"6.1.2 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u5b9e\u4f8b"},{"location":"BinaryTree/AVLTree/#62-avl","text":"Java\u7248 import java.util.Queue ; import java.util.List ; import java.util.ArrayList ; import java.util.LinkedList ; public class AVLTree < K extends Comparable < K >, V > { private class Node { public K key ; public V value ; public Node left ; public Node right ; public int height ; public Node ( K key , V value ) { this . key = key ; this . value = value ; this . left = null ; this . right = null ; this . height = 1 ; } } private Node root ; private int size ; public AVLTree () { root = null ; size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } // \u8ba1\u7b97\u9ad8\u5ea6 public int getHeight ( Node node ) { if ( node == null ) { return 0 ; } return node . height ; } // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 private int getBalanceFactor ( Node node ) { if ( node == null ) { return 0 ; } return getHeight ( node . left ) - getHeight ( node . right ); } // \u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u641c\u7d22\u6811 public boolean isBST () { List < K > keys = new ArrayList <>(); inOrder ( root , keys ); for ( int i = 1 ; i < keys . size (); i ++) { if ( keys . get ( i ). compareTo ( keys . get ( i - 1 )) < 0 ) { return false ; } } return true ; } private void inOrder ( Node node , List < K > keys ) { if ( node == null ) { return ; } inOrder ( node . left , keys ); keys . add ( node . key ); inOrder ( node . right , keys ); } // \u5224\u65ad\u662f\u5426\u4e3a\u5e73\u8861\u4e8c\u53c9\u6811 public boolean isBalanced () { return isBalanced ( root ); } private boolean isBalanced ( Node node ) { if ( node == null ) { return true ; } int balanceFactor = getBalanceFactor ( node ); if ( Math . abs ( balanceFactor ) > 1 ) { return false ; } return isBalanced ( node . left ) && isBalanced ( node . right ); } private Node getNode ( Node node , K key ) { if ( node == null ) { return null ; } if ( key . compareTo ( node . key ) < 0 ) { return getNode ( node . left , key ); } else if ( key . compareTo ( node . key ) > 0 ) { return getNode ( node . right , key ); } else { return node ; } } public boolean contains ( K key ) { return getNode ( root , key ) != null ; } public void preOrder () { preOrder ( root ); } private void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . key ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder () { inOrder ( root ); } private void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . key ); inOrder ( node . right ); } public void postOrder () { postOrder ( root ); } private void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . key ); } public void levelOrder () { Queue < Node > q = new LinkedList <>(); q . add ( root ); while (! q . isEmpty ()) { Node cur = q . remove (); System . out . println ( cur . key ); if ( cur . left != null ) { q . add ( cur . left ); } if ( cur . right != null ) { q . add ( cur . right ); } } } public V get ( K key ) { Node node = getNode ( root , key ); return node == null ? null : node . value ; } public void set ( K key , V newValue ) { Node node = getNode ( root , key ); if ( node == null ) { throw new IllegalArgumentException ( key + \"doesn't exist!\" ); } node . value = newValue ; } // \u53f3\u65cb // y x // / \\ / \\ // x T4 \u5411\u53f3\u65cb\u8f6c(y) z y // / \\ - - - - - - -> / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate ( Node y ) { Node x = y . left ; Node T3 = x . right ; x . right = y ; y . left = T3 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } // \u5de6\u65cb // y x // / \\ / \\ // T1 x \u5411\u5de6\u65cb\u8f6c(y) y z // / \\ - - - - - - -> / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate ( Node y ) { Node x = y . right ; Node T2 = x . left ; x . left = y ; y . right = T2 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } public void add ( K key , V value ) { root = add ( root , key , value ); } private Node add ( Node node , K key , V value ) { if ( node == null ) { size ++; return new Node ( key , value ); } if ( key . compareTo ( node . key ) < 0 ) { node . left = add ( node . left , key , value ); } if ( key . compareTo ( node . key ) > 0 ) { node . right = add ( node . right , key , value ); } else { node . value = value ; } // \u8ba1\u7b97\u9ad8\u5ea6 node . height = 1 + Math . max ( getHeight ( node . left ), getHeight ( node . right )); // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 int balanceFactor = getBalanceFactor ( node ); // LL if ( balanceFactor > 1 && getBalanceFactor ( node . left ) >= 0 ) { return rightRotate ( node ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) <= 0 ) { return leftRotate ( node ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( node . left ) < 0 ) { node . left = leftRotate ( node . left ); return rightRotate ( node ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) > 0 ) { node . right = rightRotate ( node . right ); return leftRotate ( node ); } return node ; } public K findMin () { if ( size == 0 ) { throw new IllegalArgumentException ( \"Can not find something from a blank tree.\" ); } return findMin ( root ). key ; } private Node findMin ( Node node ) { if ( node . left == null ) { return node ; } return findMin ( node . left ); } public K removeMin () { K ret = findMin (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public void remove ( K key ) { root = remove ( root , key ); } private Node remove ( Node node , K key ) { if ( node == null ) { return null ; } Node retNode ; if ( key . compareTo ( node . key ) < 0 ) { node . left = remove ( node . left , key ); retNode = node ; } else if ( key . compareTo ( node . key ) > 0 ) { node . right = remove ( node . right , key ); retNode = node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; retNode = rightNode ; } else if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; retNode = leftNode ; } else { Node successor = findMin ( node . right ); // successor.right = removeMin(node.right); successor . right = remove ( node . right , successor . key ); successor . left = node . left ; node . left = node . right = null ; retNode = successor ; } } if ( retNode == null ) { return null ; } retNode . height = 1 + Math . max ( getHeight ( retNode . left ), getHeight ( retNode . right )); int balanceFactor = getBalanceFactor ( retNode ); // LL if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) >= 0 ) { return rightRotate ( retNode ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) <= 0 ) { return leftRotate ( retNode ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) < 0 ) { retNode . left = leftRotate ( retNode . left ); return rightRotate ( retNode ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) > 0 ) { retNode . right = rightRotate ( retNode . right ); return leftRotate ( retNode ); } return retNode ; } }","title":"6.2 AVL\u6811\u7684\u6574\u4f53\u4ee3\u7801"},{"location":"BinaryTree/binarySearchTree/","text":"Binary Search Tree \u00b6 5.\u4e8c\u5206\u641c\u7d22\u6811(Binary Search Tree, BST) \u00b6 5.1 \u4e8c\u5206\u641c\u7d22\u6811\u7684\u6574\u4f53\u4ee3\u7801 \u00b6 Java\u7248 import java.util.LinkedList ; import java.util.Queue ; public class BST < E extends Comparable < E >> { private class Node { public E e ; public Node left ; public Node right ; public Node ( E e ) { this . e = e ; this . left = null ; this . right = null ; } } private Node root ; private int size ; public BST () { root = null ; size = 0 ; } public int size () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( E e ) { root = add ( root , e ); } // return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; } public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } } public void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . e ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . e ); inOrder ( node . right ); } public void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . e ); } public void levelOrder () { Queue < Node > queue = new LinkedList <>(); queue . add ( root ); while (! queue . isEmpty ()) { Node cur = queue . remove (); System . out . println ( cur . e ); if ( cur . left != null ) { queue . add ( cur . left ); } if ( cur . right != null ) { queue . add ( cur . right ); } } } public E minimum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return minimum ( root ). e ; } private Node minimum ( Node node ) { if ( node . left == null ) { return node ; } return minimum ( node . left ); } public E removeMin () { E ret = minimum (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public E maximum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return maximum ( root ). e ; } private Node maximum ( Node node ) { if ( node . right == null ) { return node ; } return maximum ( node . right ); } public E removeMax () { E ret = maximum (); root = removeMax ( root ); return ret ; } private Node removeMax ( Node node ) { if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } node . right = removeMax ( node . right ); return node ; } public void remove ( E e ) { root = remove ( root , e ); } private Node remove ( Node node , E e ) { if ( node == null ) { return null ; } if ( e . compareTo ( node . e ) < 0 ) { node . left = remove ( node . left , e ); return node ; } else if ( e . compareTo ( node . e ) > 0 ) { node . right = remove ( node . right , e ); return node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } Node successor = minimum ( node . right ); successor . right = removeMin ( node . right ); successor . left = node . left ; node . left = node . right = null ; return successor ; } } } 5.2 add method \u00b6 5.2.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09 \u00b6 Java\u7248 public void add ( E e ) { Node node = new Node ( e ); if ( root == null ) { root = node ; size ++; } else { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) < 0 ) { if ( temp . left == null ) { temp . left = node ; size ++; return ; } else { temp = temp . left ; } } else { if ( temp . right == null ) { temp . right = node ; szie ++; return ; } else { temp = temp . right ; } } } } } 5.2.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09 \u00b6 Java\u7248 public void add ( E e ) { if ( root == null ) { root = new Node ( e ); size ++; } else { add ( root , e ); } } private void add ( Node node , E e ) { if ( e . equals ( node . e )) { return ; } else if ( e . compareTo ( node . e ) < 0 && node . left == null ) { node . left = new Node ( e ); size ++; return ; } else if ( e . compareTo ( node . e ) > 0 && node . right == null ) { node . right = new Node ( e ); size ++; return ; } if ( e . compareTo ( node . e ) < 0 ) { add ( node . left , e ); } else { add ( node . right , e ); } } 5.2.3 \u9012\u5f52\u5b9e\u73b0\uff08optimize and refactor recursion method\uff09 \u00b6 Java\u7248 // recurse method optimization and refactor public void add ( E e ) { root = add ( root , e ); } //return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; } 5.3 search method \u00b6 5.3.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09 \u00b6 Java\u7248 public boolean contains ( E e ) { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) == 0 ) { return true ; } else if ( e . compareTo ( temp . e ) < 0 ) { temp = temp . left ; } else { temp = temp . right ; } } return false ; } 5.3.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09 \u00b6 Java\u7248 public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } } 5.4 traversal method \u00b6 5.4.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09 \u00b6 \u6808stack\u5b9e\u73b0 public void preOrder () { Stack < Node > stack = new Stack < > (); stack . push ( root ); while (! stack . isEmpty ()) { Node cur = stack . pop (); System . out . println ( cur . e ); if ( cur . right != null ) { stack . push ( cur . right ); } if ( cur . left != null ) { stack . push ( cur . left ); } } } 5.4.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09 \u00b6 Java\u7248 public void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . e ); preOrder ( node . left ); preOrder ( node . right ); }","title":"2. bst"},{"location":"BinaryTree/binarySearchTree/#binary-search-tree","text":"","title":"Binary Search Tree"},{"location":"BinaryTree/binarySearchTree/#5binary-search-tree-bst","text":"","title":"5.\u4e8c\u5206\u641c\u7d22\u6811(Binary Search Tree, BST)"},{"location":"BinaryTree/binarySearchTree/#51","text":"Java\u7248 import java.util.LinkedList ; import java.util.Queue ; public class BST < E extends Comparable < E >> { private class Node { public E e ; public Node left ; public Node right ; public Node ( E e ) { this . e = e ; this . left = null ; this . right = null ; } } private Node root ; private int size ; public BST () { root = null ; size = 0 ; } public int size () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( E e ) { root = add ( root , e ); } // return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; } public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } } public void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . e ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . e ); inOrder ( node . right ); } public void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . e ); } public void levelOrder () { Queue < Node > queue = new LinkedList <>(); queue . add ( root ); while (! queue . isEmpty ()) { Node cur = queue . remove (); System . out . println ( cur . e ); if ( cur . left != null ) { queue . add ( cur . left ); } if ( cur . right != null ) { queue . add ( cur . right ); } } } public E minimum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return minimum ( root ). e ; } private Node minimum ( Node node ) { if ( node . left == null ) { return node ; } return minimum ( node . left ); } public E removeMin () { E ret = minimum (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public E maximum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return maximum ( root ). e ; } private Node maximum ( Node node ) { if ( node . right == null ) { return node ; } return maximum ( node . right ); } public E removeMax () { E ret = maximum (); root = removeMax ( root ); return ret ; } private Node removeMax ( Node node ) { if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } node . right = removeMax ( node . right ); return node ; } public void remove ( E e ) { root = remove ( root , e ); } private Node remove ( Node node , E e ) { if ( node == null ) { return null ; } if ( e . compareTo ( node . e ) < 0 ) { node . left = remove ( node . left , e ); return node ; } else if ( e . compareTo ( node . e ) > 0 ) { node . right = remove ( node . right , e ); return node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } Node successor = minimum ( node . right ); successor . right = removeMin ( node . right ); successor . left = node . left ; node . left = node . right = null ; return successor ; } } }","title":"5.1 \u4e8c\u5206\u641c\u7d22\u6811\u7684\u6574\u4f53\u4ee3\u7801"},{"location":"BinaryTree/binarySearchTree/#52-add-method","text":"","title":"5.2 add method"},{"location":"BinaryTree/binarySearchTree/#521-not-recursion","text":"Java\u7248 public void add ( E e ) { Node node = new Node ( e ); if ( root == null ) { root = node ; size ++; } else { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) < 0 ) { if ( temp . left == null ) { temp . left = node ; size ++; return ; } else { temp = temp . left ; } } else { if ( temp . right == null ) { temp . right = node ; szie ++; return ; } else { temp = temp . right ; } } } } }","title":"5.2.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#522-recursion","text":"Java\u7248 public void add ( E e ) { if ( root == null ) { root = new Node ( e ); size ++; } else { add ( root , e ); } } private void add ( Node node , E e ) { if ( e . equals ( node . e )) { return ; } else if ( e . compareTo ( node . e ) < 0 && node . left == null ) { node . left = new Node ( e ); size ++; return ; } else if ( e . compareTo ( node . e ) > 0 && node . right == null ) { node . right = new Node ( e ); size ++; return ; } if ( e . compareTo ( node . e ) < 0 ) { add ( node . left , e ); } else { add ( node . right , e ); } }","title":"5.2.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#523-optimize-and-refactor-recursion-method","text":"Java\u7248 // recurse method optimization and refactor public void add ( E e ) { root = add ( root , e ); } //return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; }","title":"5.2.3 \u9012\u5f52\u5b9e\u73b0\uff08optimize and refactor recursion method\uff09"},{"location":"BinaryTree/binarySearchTree/#53-search-method","text":"","title":"5.3 search method"},{"location":"BinaryTree/binarySearchTree/#531-not-recursion","text":"Java\u7248 public boolean contains ( E e ) { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) == 0 ) { return true ; } else if ( e . compareTo ( temp . e ) < 0 ) { temp = temp . left ; } else { temp = temp . right ; } } return false ; }","title":"5.3.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#532-recursion","text":"Java\u7248 public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } }","title":"5.3.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#54-traversal-method","text":"","title":"5.4 traversal method"},{"location":"BinaryTree/binarySearchTree/#541-not-recursion","text":"\u6808stack\u5b9e\u73b0 public void preOrder () { Stack < Node > stack = new Stack < > (); stack . push ( root ); while (! stack . isEmpty ()) { Node cur = stack . pop (); System . out . println ( cur . e ); if ( cur . right != null ) { stack . push ( cur . right ); } if ( cur . left != null ) { stack . push ( cur . left ); } } }","title":"5.4.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#542-recursion","text":"Java\u7248 public void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . e ); preOrder ( node . left ); preOrder ( node . right ); }","title":"5.4.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09"},{"location":"BinaryTree/binaryTree/","text":"\u4e8c\u53c9\u6811 \u00b6 1.\u4e8c\u53c9\u6811\u904d\u5386 \u00b6 1.1 \u524d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u6839\u7ed3\u70b9->\u5de6\u5b50\u6811->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.2 \u4e2d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u6839\u7ed3\u70b9->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.3 \u540e\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u53f3\u5b50\u6811->\u6839\u7ed3\u70b9\u7684\u987a\u5e8f\u8bbf\u95ee 2.\u524d\u5e8f\u904d\u5386\uff0c\u4e2d\u5e8f\u904d\u5386\u4e0e\u540e\u5e8f\u904d\u5386\u4e4b\u95f4\u7684\u63a8\u5bfc \u00b6 2.1 \u5df2\u77e5\u524d\u5e8f\u548c\u4e2d\u5e8f\uff1a \u4ece\u524d\u5e8f\u4e2d\u627e\u6839\u7ed3\u70b9root1 \u5728\u4e2d\u5e8f\u4e2d\u6839\u636e\u6839\u7ed3\u70b9root1\u5c06\u5176\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u4ece\u524d\u5e8f\u4e2d\u627e\u5de6\u5b50\u6811\u7684\u6839\u7ed3\u70b9root2 \u5728\u4e2d\u5e8f\u4e2d\u5c06\u5de6\u5b50\u6811\u6839\u636e\u6839\u7ed3\u70b9root2\u5c06\u5de6\u5b50\u6811\u53c8\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u5faa\u73af\u4e0a\u8ff0\u8fc7\u7a0b\uff0c\u753b\u51fa\u4e8c\u53c9\u6811\u56fe\uff0c\u518d\u5f97\u5230\u540e\u5e8f\u904d\u5386 2.2 \u5df2\u77e5\u4e2d\u5e8f\u548c\u540e\u5e8f\uff1a \u63d0\u793a\uff1a\u540e\u5e8f\u7684\u6700\u540e\u4e00\u4e2a\u4e3a\u6811\u7684\u6839\u7ed3\u70b9 2.3 \u5df2\u77e5\u524d\u5e8f\u548c\u540e\u5e8f\uff1a\u7b54\u6848\u4e0d\u552f\u4e00 3.\u4e8c\u53c9\u6811\u7684\u6027\u8d28 \u00b6 \u5728\u4e8c\u53c9\u6811\u7684\u7b2ci\u5c42\u4e0a\u6700\u591a\u67092(i-1)\u4e2a\u7ed3\u70b9 \u4e8c\u53c9\u6811\u4e2d\u5982\u679c\u6df1\u5ea6\u4e3ak(\u6709k\u5c42),\u90a3\u4e48\u6700\u591a\u67092^k - 1\u4e2a\u7ed3\u70b9 4.\u4e8c\u53c9\u6811\u7684\u5f62\u6001 \u00b6 4.1 \u5b8c\u7f8e\u4e8c\u53c9\u6811(\u6ee1\u4e8c\u53c9\u6811 Perfect Binary Tree, BST) \u9ad8\u5ea6\u4e3ak\u7684\u4e8c\u53c9\u6811\u67092^k - 1\u4e2a\u7ed3\u70b9 4.2 \u5b8c\u5168\u4e8c\u53c9\u6811(Complete Binary Tree, CBT) \u4ece\u6839\u7ed3\u70b9\u5230\u5012\u6570\u7b2c\u4e8c\u5c42\u6ee1\u8db3\u5b8c\u7f8e\u4e8c\u53c9\u6811\uff0c\u6700\u540e\u4e00\u5c42\u53ef\u4ee5\u4e0d\u5b8c\u5168\u586b\u5145\uff0c\u5176\u53f6\u5b50\u7ed3\u70b9\u90fd\u9760\u5de6\u5bf9\u9f50 \u53f6\u5b50\u7ed3\u70b9\u7684\u6700\u5927\u6df1\u5ea6\u4e0e\u6700\u5c0f\u6df1\u5ea6\u5dee\u4e0d\u8d85\u8fc71 4.3 \u5b8c\u6ee1\u4e8c\u53c9\u6811(Full Binary Tree, FBT) \u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f2 4.4 \u4e09\u8005\u7684\u6bd4\u8f83 4.5 \u5e73\u8861\u4e8c\u53c9\u6811(Balanced Binary Tree) \u4efb\u610f\u7ed3\u70b9\u7684\u5de6\u5b50\u6811\u4e0e\u53f3\u5b50\u6811\u9ad8\u5ea6\u5dee\u4e0d\u8d85\u8fc71","title":"1. binaryTree"},{"location":"BinaryTree/binaryTree/#_1","text":"","title":"\u4e8c\u53c9\u6811"},{"location":"BinaryTree/binaryTree/#1","text":"1.1 \u524d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u6839\u7ed3\u70b9->\u5de6\u5b50\u6811->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.2 \u4e2d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u6839\u7ed3\u70b9->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.3 \u540e\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u53f3\u5b50\u6811->\u6839\u7ed3\u70b9\u7684\u987a\u5e8f\u8bbf\u95ee","title":"1.\u4e8c\u53c9\u6811\u904d\u5386"},{"location":"BinaryTree/binaryTree/#2","text":"2.1 \u5df2\u77e5\u524d\u5e8f\u548c\u4e2d\u5e8f\uff1a \u4ece\u524d\u5e8f\u4e2d\u627e\u6839\u7ed3\u70b9root1 \u5728\u4e2d\u5e8f\u4e2d\u6839\u636e\u6839\u7ed3\u70b9root1\u5c06\u5176\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u4ece\u524d\u5e8f\u4e2d\u627e\u5de6\u5b50\u6811\u7684\u6839\u7ed3\u70b9root2 \u5728\u4e2d\u5e8f\u4e2d\u5c06\u5de6\u5b50\u6811\u6839\u636e\u6839\u7ed3\u70b9root2\u5c06\u5de6\u5b50\u6811\u53c8\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u5faa\u73af\u4e0a\u8ff0\u8fc7\u7a0b\uff0c\u753b\u51fa\u4e8c\u53c9\u6811\u56fe\uff0c\u518d\u5f97\u5230\u540e\u5e8f\u904d\u5386 2.2 \u5df2\u77e5\u4e2d\u5e8f\u548c\u540e\u5e8f\uff1a \u63d0\u793a\uff1a\u540e\u5e8f\u7684\u6700\u540e\u4e00\u4e2a\u4e3a\u6811\u7684\u6839\u7ed3\u70b9 2.3 \u5df2\u77e5\u524d\u5e8f\u548c\u540e\u5e8f\uff1a\u7b54\u6848\u4e0d\u552f\u4e00","title":"2.\u524d\u5e8f\u904d\u5386\uff0c\u4e2d\u5e8f\u904d\u5386\u4e0e\u540e\u5e8f\u904d\u5386\u4e4b\u95f4\u7684\u63a8\u5bfc"},{"location":"BinaryTree/binaryTree/#3","text":"\u5728\u4e8c\u53c9\u6811\u7684\u7b2ci\u5c42\u4e0a\u6700\u591a\u67092(i-1)\u4e2a\u7ed3\u70b9 \u4e8c\u53c9\u6811\u4e2d\u5982\u679c\u6df1\u5ea6\u4e3ak(\u6709k\u5c42),\u90a3\u4e48\u6700\u591a\u67092^k - 1\u4e2a\u7ed3\u70b9","title":"3.\u4e8c\u53c9\u6811\u7684\u6027\u8d28"},{"location":"BinaryTree/binaryTree/#4","text":"4.1 \u5b8c\u7f8e\u4e8c\u53c9\u6811(\u6ee1\u4e8c\u53c9\u6811 Perfect Binary Tree, BST) \u9ad8\u5ea6\u4e3ak\u7684\u4e8c\u53c9\u6811\u67092^k - 1\u4e2a\u7ed3\u70b9 4.2 \u5b8c\u5168\u4e8c\u53c9\u6811(Complete Binary Tree, CBT) \u4ece\u6839\u7ed3\u70b9\u5230\u5012\u6570\u7b2c\u4e8c\u5c42\u6ee1\u8db3\u5b8c\u7f8e\u4e8c\u53c9\u6811\uff0c\u6700\u540e\u4e00\u5c42\u53ef\u4ee5\u4e0d\u5b8c\u5168\u586b\u5145\uff0c\u5176\u53f6\u5b50\u7ed3\u70b9\u90fd\u9760\u5de6\u5bf9\u9f50 \u53f6\u5b50\u7ed3\u70b9\u7684\u6700\u5927\u6df1\u5ea6\u4e0e\u6700\u5c0f\u6df1\u5ea6\u5dee\u4e0d\u8d85\u8fc71 4.3 \u5b8c\u6ee1\u4e8c\u53c9\u6811(Full Binary Tree, FBT) \u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f2 4.4 \u4e09\u8005\u7684\u6bd4\u8f83 4.5 \u5e73\u8861\u4e8c\u53c9\u6811(Balanced Binary Tree) \u4efb\u610f\u7ed3\u70b9\u7684\u5de6\u5b50\u6811\u4e0e\u53f3\u5b50\u6811\u9ad8\u5ea6\u5dee\u4e0d\u8d85\u8fc71","title":"4.\u4e8c\u53c9\u6811\u7684\u5f62\u6001"},{"location":"BinaryTree/redblackTree/","text":"Red Black Tree \u00b6 \u7ea2\u9ed1\u6811(Red Black Tree, RBT) \u00b6 \u7b49\u4ef7\u4e8e2-3\u6811(2-3\u6811\u5177\u6709\u7edd\u5bf9\u5e73\u8861\u6027)\uff0c\u5728\u6dfb\u52a0\u548c\u5220\u9664\u6027\u80fd\u4e0a\u4f18\u4e8eAVL 1.\u6240\u6709\u7ed3\u70b9\u7684\u989c\u8272\u4e0d\u662f\u7ea2\u8272\u5c31\u662f\u9ed1\u8272 2.\u6839\u7ed3\u70b9\u7684\u989c\u8272\u4e3a\u9ed1\u8272 3.\u6bcf\u4e00\u4e2a\u53f6\u5b50\u7ed3\u70b9(\u6700\u540e\u7684\u7a7a\u8282\u70b9)\u662f\u9ed1\u8272\u7684 4.\u7ea2\u8272\u7ed3\u70b9\u7684\u4e24\u4e2a\u5b69\u5b50\u90fd\u4e3a\u9ed1\u8272 5.\u4ece\u4efb\u610f\u7ed3\u70b9\u51fa\u53d1\u5230\u53f6\u5b50\u7ed3\u70b9\u7ecf\u8fc7\u7684\u9ed1\u8272\u7ed3\u70b9\u6570\u91cf\u76f8\u540c","title":"4. rbTree"},{"location":"BinaryTree/redblackTree/#red-black-tree","text":"","title":"Red Black Tree"},{"location":"BinaryTree/redblackTree/#red-black-tree-rbt","text":"\u7b49\u4ef7\u4e8e2-3\u6811(2-3\u6811\u5177\u6709\u7edd\u5bf9\u5e73\u8861\u6027)\uff0c\u5728\u6dfb\u52a0\u548c\u5220\u9664\u6027\u80fd\u4e0a\u4f18\u4e8eAVL 1.\u6240\u6709\u7ed3\u70b9\u7684\u989c\u8272\u4e0d\u662f\u7ea2\u8272\u5c31\u662f\u9ed1\u8272 2.\u6839\u7ed3\u70b9\u7684\u989c\u8272\u4e3a\u9ed1\u8272 3.\u6bcf\u4e00\u4e2a\u53f6\u5b50\u7ed3\u70b9(\u6700\u540e\u7684\u7a7a\u8282\u70b9)\u662f\u9ed1\u8272\u7684 4.\u7ea2\u8272\u7ed3\u70b9\u7684\u4e24\u4e2a\u5b69\u5b50\u90fd\u4e3a\u9ed1\u8272 5.\u4ece\u4efb\u610f\u7ed3\u70b9\u51fa\u53d1\u5230\u53f6\u5b50\u7ed3\u70b9\u7ecf\u8fc7\u7684\u9ed1\u8272\u7ed3\u70b9\u6570\u91cf\u76f8\u540c","title":"\u7ea2\u9ed1\u6811(Red Black Tree, RBT)"}]}