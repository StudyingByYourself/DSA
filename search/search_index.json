{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my site \u00b6 \u5185\u5bb9 \u00b6 \u8fd9\u91cc\u4e3b\u8981\u5206\u4eab\u4e00\u4e9b\u6211\u5b66\u4e60\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5\u7684\u7b14\u8bb0\uff0c\u6570\u636e\u7ed3\u6784\u5305\u62ec\u6570\u7ec4\uff0c\u94fe\u8868\uff0c\u961f\u5217\uff0c\u6808\uff0c\u4e8c\u5206\u641c\u7d22\u6811\uff0cAVL\u6811\uff0c\u7ea2\u9ed1\u6811\uff1b\u7b97\u6cd5\u9898\u4e3b\u8981\u662f\u901a\u8fc7\u5728lincode\u7684\u7ec3\u4e60\u6765\u719f\u7ec3\uff0c\u7279\u522b\u5bf9\u52a8\u6001\u89c4\u5212(DP)\u8fd9\u4e00\u7c7b\u7b97\u6cd5\u95ee\u9898\u8fdb\u884c\u4e86\u8be6\u7ec6\u8bf4\u660e\u3002 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u4e00. \u4ecb\u7ecd"},{"location":"#welcome-to-my-site","text":"","title":"Welcome to my site"},{"location":"#_1","text":"\u8fd9\u91cc\u4e3b\u8981\u5206\u4eab\u4e00\u4e9b\u6211\u5b66\u4e60\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5\u7684\u7b14\u8bb0\uff0c\u6570\u636e\u7ed3\u6784\u5305\u62ec\u6570\u7ec4\uff0c\u94fe\u8868\uff0c\u961f\u5217\uff0c\u6808\uff0c\u4e8c\u5206\u641c\u7d22\u6811\uff0cAVL\u6811\uff0c\u7ea2\u9ed1\u6811\uff1b\u7b97\u6cd5\u9898\u4e3b\u8981\u662f\u901a\u8fc7\u5728lincode\u7684\u7ec3\u4e60\u6765\u719f\u7ec3\uff0c\u7279\u522b\u5bf9\u52a8\u6001\u89c4\u5212(DP)\u8fd9\u4e00\u7c7b\u7b97\u6cd5\u95ee\u9898\u8fdb\u884c\u4e86\u8be6\u7ec6\u8bf4\u660e\u3002 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u5185\u5bb9"},{"location":"BuyAndSellStock/","text":"\u4e70\u80a1\u7968\u95ee\u9898 \u00b6 Best Time to Buy and Sell Stock 149 \u00b6 \u65b9\u6cd5\u4e00\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n 2 ) \u00b6 \u4e24\u6b21for\u5faa\u73af\uff0c\u7b2c\u4e00\u5c42\u5faa\u73af\u5bfb\u627e\u4e70\u5165\u4ef7\uff0c\u7b2c\u4e8c\u5c42\u5faa\u73af\u5bfb\u627e\u5356\u51fa\u4ef7 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ for ( int j = i + 1 ; j < n ; j ++) { if ( prices [ j ] - prices [ i ] > profit ){ profit = prices [ j ] - prices [ i ]; } } } return profit ; } } \u65b9\u6cd5\u4e8c\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) \u00b6 \u4e00\u6b21for\u5faa\u73af\uff0cmin\u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5c0f\u503c\uff0cprofit\u8bb0\u5f55\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u83b7\u76ca\u3002 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; int min = prices [ 0 ]; for ( int i = 1 ; i < n ; i ++){ min = Math . min ( min , prices [ i ]); profit = Math . max ( profit , prices [ i ] - min ); } return profit ; } } Best Time to Buy and Sell Stock II 150 \u00b6 \u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) \u4e00\u6b21for\u5faa\u73af\uff0cprofit\u7d2f\u52a0\u4e0a\u76f8\u90bb\u4e24\u6b21\u80a1\u7968\u5dee\u4e3a\u6b63\u6570\u7684\u6536\u76ca Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ){ return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ if ( prices [ i + 1 ] - prices [ i ] > 0 ){ profit += prices [ i + 1 ] - prices [ i ]; } } return profit ; } } Best Time to Buy and Sell Stock III 151 \u00b6 \u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) f[i][j]\u8868\u793a\u524di\u5929\u5728j\u72b6\u6001\u7684\u6700\u5927\u6536\u76ca(eg:\u524d1\u5929\u7684\u4e0b\u6807\u4e3a0) \u5f53\u5904\u4e8e\u975e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j] = max{f[i-1][j], f[i-1][j-1] + A[i-1] \u2013 A[i-2]} \u5f53\u5904\u4e8e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j]=max{f[i-1][j-1], f[i-1][j]+A[i-1]\u2013A[i-2], f[i-1][j-2]+A[i-1]\u2013A[i-2]} Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ n + 1 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } } \u5bf9\u7a7a\u95f4\u8fdb\u884c\u4f18\u5316:\u7a7a\u95f4\u590d\u6742\u5ea6O(1) Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ 2 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } int old = 0 ; int now = 1 ; for ( int i = 1 ; i < n + 1 ; i ++) { old = now ; now = 1 - now ; for ( int j = 1 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j ]; if ( i > 1 && j > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 1 ]+ A [ i - 1 ]- A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j - 1 ]; if ( i > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j ]+ A [ i - 1 ]- A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 2 ]+ A [ i - 1 ]- A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ now ][ j ] > profit ) { profit = f [ now ][ j ]; } } return profit ; } } Best Time to Buy and Sell Stock IV 393 \u00b6 Java\u7248 public class Solution { /** * @param K: An integer * @param prices: An integer array * @return: Maximum profit */ public int maxProfit ( int K , int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } if ( K > n / 2 ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++) { if ( A [ i + 1 ] > A [ i ]) { res += A [ i + 1 ] - A [ i ]; } } return res ; } int [][] f = new int [ n + 1 ][ 2 * K + 1 + 1 ]; for ( int j = 0 ; j < 2 * K + 2 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } }","title":"2.1 Best Time to Buy and Sell Stock"},{"location":"BuyAndSellStock/#_1","text":"","title":"\u4e70\u80a1\u7968\u95ee\u9898"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-149","text":"","title":"Best Time to Buy and Sell Stock 149"},{"location":"BuyAndSellStock/#on2","text":"\u4e24\u6b21for\u5faa\u73af\uff0c\u7b2c\u4e00\u5c42\u5faa\u73af\u5bfb\u627e\u4e70\u5165\u4ef7\uff0c\u7b2c\u4e8c\u5c42\u5faa\u73af\u5bfb\u627e\u5356\u51fa\u4ef7 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ for ( int j = i + 1 ; j < n ; j ++) { if ( prices [ j ] - prices [ i ] > profit ){ profit = prices [ j ] - prices [ i ]; } } } return profit ; } }","title":"\u65b9\u6cd5\u4e00\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n2)"},{"location":"BuyAndSellStock/#on","text":"\u4e00\u6b21for\u5faa\u73af\uff0cmin\u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5c0f\u503c\uff0cprofit\u8bb0\u5f55\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u6700\u5927\u83b7\u76ca\u3002 Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ) { return 0 ; } int profit = 0 ; int min = prices [ 0 ]; for ( int i = 1 ; i < n ; i ++){ min = Math . min ( min , prices [ i ]); profit = Math . max ( profit , prices [ i ] - min ); } return profit ; } }","title":"\u65b9\u6cd5\u4e8c\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n)"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-ii-150","text":"\u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) \u4e00\u6b21for\u5faa\u73af\uff0cprofit\u7d2f\u52a0\u4e0a\u76f8\u90bb\u4e24\u6b21\u80a1\u7968\u5dee\u4e3a\u6b63\u6570\u7684\u6536\u76ca Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] prices ) { int n = prices . length ; if ( 0 == n ){ return 0 ; } int profit = 0 ; for ( int i = 0 ; i < n - 1 ; i ++){ if ( prices [ i + 1 ] - prices [ i ] > 0 ){ profit += prices [ i + 1 ] - prices [ i ]; } } return profit ; } }","title":"Best Time to Buy and Sell Stock II 150"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-iii-151","text":"\u65b9\u6cd5\uff1a\u65f6\u95f4\u590d\u6742\u5ea6O(n) f[i][j]\u8868\u793a\u524di\u5929\u5728j\u72b6\u6001\u7684\u6700\u5927\u6536\u76ca(eg:\u524d1\u5929\u7684\u4e0b\u6807\u4e3a0) \u5f53\u5904\u4e8e\u975e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j] = max{f[i-1][j], f[i-1][j-1] + A[i-1] \u2013 A[i-2]} \u5f53\u5904\u4e8e\u6301\u80a1\u72b6\u6001\u65f6\uff0c\u8003\u8651\u524d\u4e00\u5929\u5904\u4e8e\u975e\u6301\u80a1\u6216\u8005\u6301\u80a1\u72b6\u6001 f[i][j]=max{f[i-1][j-1], f[i-1][j]+A[i-1]\u2013A[i-2], f[i-1][j-2]+A[i-1]\u2013A[i-2]} Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ n + 1 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } } \u5bf9\u7a7a\u95f4\u8fdb\u884c\u4f18\u5316:\u7a7a\u95f4\u590d\u6742\u5ea6O(1) Java\u7248 public class Solution { /** * @param prices: Given an integer array * @return: Maximum profit */ public int maxProfit ( int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } int [][] f = new int [ 2 ][ 5 + 1 ]; for ( int j = 0 ; j < 6 ; j ++) { f [ 0 ][ j ] = 0 ; } int old = 0 ; int now = 1 ; for ( int i = 1 ; i < n + 1 ; i ++) { old = now ; now = 1 - now ; for ( int j = 1 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j ]; if ( i > 1 && j > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 1 ]+ A [ i - 1 ]- A [ i - 2 ]); } } for ( int j = 2 ; j < 6 ; j += 2 ) { f [ now ][ j ] = f [ old ][ j - 1 ]; if ( i > 1 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j ]+ A [ i - 1 ]- A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ now ][ j ] = Math . max ( f [ now ][ j ], f [ old ][ j - 2 ]+ A [ i - 1 ]- A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 6 ; j += 2 ) { if ( f [ now ][ j ] > profit ) { profit = f [ now ][ j ]; } } return profit ; } }","title":"Best Time to Buy and Sell Stock III 151"},{"location":"BuyAndSellStock/#best-time-to-buy-and-sell-stock-iv-393","text":"Java\u7248 public class Solution { /** * @param K: An integer * @param prices: An integer array * @return: Maximum profit */ public int maxProfit ( int K , int [] A ) { int n = A . length ; if ( 0 == n ) { return 0 ; } if ( K > n / 2 ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++) { if ( A [ i + 1 ] > A [ i ]) { res += A [ i + 1 ] - A [ i ]; } } return res ; } int [][] f = new int [ n + 1 ][ 2 * K + 1 + 1 ]; for ( int j = 0 ; j < 2 * K + 2 ; j ++) { f [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < n + 1 ; i ++) { for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( i > 1 && j > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 1 ] + A [ i - 1 ] - A [ i - 2 ]); } } for ( int j = 2 ; j < 2 * K + 2 ; j += 2 ) { f [ i ][ j ] = f [ i - 1 ][ j - 1 ]; if ( i > 1 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j ] + A [ i - 1 ] - A [ i - 2 ]); } if ( i > 1 && j > 2 ) { f [ i ][ j ] = Math . max ( f [ i ][ j ], f [ i - 1 ][ j - 2 ] + A [ i - 1 ] - A [ i - 2 ]); } } } int profit = 0 ; for ( int j = 1 ; j < 2 * K + 2 ; j += 2 ) { if ( f [ n ][ j ] > profit ) { profit = f [ n ][ j ]; } } return profit ; } }","title":"Best Time to Buy and Sell Stock IV 393"},{"location":"backpack/","text":"Backpack \u00b6 \u80cc\u5305\u95ee\u9898\u53c2\u8003 \u80cc\u5305\u95ee\u9898\u80cc\u666f\uff1a\u5728\u4e00\u5b9a\u5bb9\u91cf\u7684\u80cc\u5305\u4e2d\u88c5\u5165\u542b\u6709\u4e0d\u540c\u5bb9\u91cf\u548c\u4ef7\u503c\u7684\u7269\u54c1 ( https://blog.csdn.net/ppp_1026hc/article/details/52138025 ) 0-1\u80cc\u5305 \u00b6 Backpack 92 \u00b6 f[i][j] means whether the former i number can make up j. f[i][j] = f[i-1][j] || (f[i-1][j-A[i-1]] | j-A[i-1] >= 0) \u4ee3\u7801\u5b9e\u73b0 public class Backpack { public int backPack ( int m , int [] A ) { int n = A . length ; if ( n == 0 ) { return 0 ; } boolean [][] f = new boolean [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ 0 ][ j ] = false ; } for ( int i = 1 ; i < n + 1 ; i ++) { f [ i ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 ) { f [ i ][ j ] = f [ i ][ j ] || f [ i - 1 ][ j - A [ i - 1 ]]; } } } for ( int j = m ; j >= 0 ; j --) { if ( f [ n ][ j ]) { return j ; } } return 0 ; } } \u5b9e\u9645\u95ee\u9898 \u00b6 \u6dd8\u5b9d\u4e0a\u7684\u5929\u732b\u8d85\u5e02\u6709\u6ee1199\u51cf100\u7684\u6d3b\u52a8\uff0c\u5982\u4f55\u51d1\u5355\u80fd\u6ee1199\uff0c\u5e76\u4e14\u5c3d\u91cf\u63a5\u8fd1199\uff1f \u5373\u6c42\u5927\u4e8e\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6700\u5c0f\u503c\uff0c\u5e76\u4e14\u8f93\u51fa\u4e00\u79cd\u5177\u4f53\u7684\u65b9\u6848\u3002 \u601d\u8def(\u6c42\u5927\u4e8e\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6700\u5c0f\u503c)\uff1a f[i][j] means whether the former i number can make up j. \u5728new f[n + 1][target + 1] \u65f6\u5c06target\u6269\u5927\u4e24\u500d,f[n + 1][target * 2 + 1] \u4ecef[n][target]\u5f00\u59cb\u5bfb\u627e\uff0c\u82e5\u4e0d\u4e3a\u771f\uff0c\u5219\u5c06target += 1\uff0c\u76f4\u5230f[n][target]\u4e3a\u771f\u3002 \u601d\u8def(\u8f93\u51fa\u4e00\u79cd\u5177\u4f53\u7684\u65b9\u6848)\uff1a \u7528pai[i][j] \u8868\u793a\u62fc\u51faj\u7684\u6700\u540e\u4e00\u4e2a\u6570\u53ef\u4ee5\u662fpai[i][j] Java\u5b9e\u73b0 public class Shopping { public static void shoppingSnacks ( int [] prices , int target ) { int n = prices . length ; if ( n == 0 && target != 0 ) { return ; } boolean [][] f = new boolean [ n + 1 ][ target * 2 + 1 ]; int [][] pai = new int [ n + 1 ][ target * 2 + 1 ]; f [ 0 ][ 0 ] = true ; for ( int i = 1 ; i < f . length ; i ++) { for ( int j = 0 ; j < f [ 0 ]. length ; j ++) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - prices [ i - 1 ] >= 0 ) { f [ i ][ j ] = f [ i ][ j ] || f [ i - 1 ][ j - prices [ i - 1 ]]; if ( f [ i - 1 ][ j - prices [ i - 1 ]]) { pai [ i ][ j ] = prices [ i - 1 ]; } } } } // \u9009\u62e9\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6700\u5c0f\u503c while (! f [ n ][ target ] && target < f [ 0 ]. length - 1 ) { target ++; } // \u6253\u5370\u8d2d\u7269\u8f66\u6e05\u5355 if ( f [ n ][ target ]) { int p = target ; int q = n ; System . out . println ( p + \" = \" ); while ( p > 0 ) { System . out . println ( pai [ q ][ p ]); p -= pai [ q ][ p ]; q --; while ( pai [ q ][ p ] == 0 && q > 0 ) { q --; } } } else { System . out . println ( \"\u6ca1\u6709\u6ee1\u8db3\u8981\u6c42\u7684\u65b9\u6848\" ); } } } int[] arr = {2, 3, 5},int target = 8; BackpackII 125 \u00b6 f[i][j] means the maximum value of the former i number making up j. f[i][j] = max{f[i-1][j], f[i-1][j-A[i-1]] + V[i-1] | j-A[i-1] >= 0} \u4ee3\u7801\u5b9e\u73b0 public class BackpackII { public int backPackII ( int m , int [] A , int [] V ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [][] f = new int [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ 0 ][ j ] = - 1 ; } for ( int i = 1 ; i < n + 1 ; i ++){ f [ i ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 && f [ i - 1 ][ j - A [ i - 1 ]] != - 1 ){ f [ i ][ j ]= Math . max ( f [ i ][ j ], f [ i - 1 ][ j - A [ i - 1 ]]+ V [ i - 1 ]); } } } int res = 0 ; for ( int j = 0 ; j < m + 1 ; j ++){ res = Math . max ( res , f [ n ][ j ]); } return res ; } } \u5b8c\u5168\u80cc\u5305 \u00b6 BackpackIII 440 \u00b6 f[i] means the maximum value of size i, if f[i] doen't exist,using Integer.MIN_VALUE to represent it. f[i] = max{f[i-A[j]] + V[j]} \u4ee3\u7801\u5b9e\u73b0 public class BackpackIII { public int backPackIII ( int [] A , int [] V , int m ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [] f = new int [ m + 1 ]; f [ 0 ] = 0 ; for ( int i = 1 ; i < m + 1 ; i ++){ f [ i ] = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++){ if ( i - A [ j ] >= 0 && f [ i - A [ j ]] + V [ j ] > f [ i ]){ f [ i ] = f [ i - A [ j ]] + V [ j ]; } } } int res = 0 ; for ( int i = 0 ; i < m + 1 ; i ++){ res = Math . max ( res , f [ i ]); } return res ; } }","title":"1. backpack"},{"location":"backpack/#backpack","text":"\u80cc\u5305\u95ee\u9898\u53c2\u8003 \u80cc\u5305\u95ee\u9898\u80cc\u666f\uff1a\u5728\u4e00\u5b9a\u5bb9\u91cf\u7684\u80cc\u5305\u4e2d\u88c5\u5165\u542b\u6709\u4e0d\u540c\u5bb9\u91cf\u548c\u4ef7\u503c\u7684\u7269\u54c1 ( https://blog.csdn.net/ppp_1026hc/article/details/52138025 )","title":"Backpack"},{"location":"backpack/#0-1","text":"","title":"0-1\u80cc\u5305"},{"location":"backpack/#backpack-92","text":"f[i][j] means whether the former i number can make up j. f[i][j] = f[i-1][j] || (f[i-1][j-A[i-1]] | j-A[i-1] >= 0) \u4ee3\u7801\u5b9e\u73b0 public class Backpack { public int backPack ( int m , int [] A ) { int n = A . length ; if ( n == 0 ) { return 0 ; } boolean [][] f = new boolean [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ 0 ][ j ] = false ; } for ( int i = 1 ; i < n + 1 ; i ++) { f [ i ][ 0 ] = true ; for ( int j = 1 ; j < m + 1 ; j ++) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 ) { f [ i ][ j ] = f [ i ][ j ] || f [ i - 1 ][ j - A [ i - 1 ]]; } } } for ( int j = m ; j >= 0 ; j --) { if ( f [ n ][ j ]) { return j ; } } return 0 ; } }","title":"Backpack 92"},{"location":"backpack/#_1","text":"\u6dd8\u5b9d\u4e0a\u7684\u5929\u732b\u8d85\u5e02\u6709\u6ee1199\u51cf100\u7684\u6d3b\u52a8\uff0c\u5982\u4f55\u51d1\u5355\u80fd\u6ee1199\uff0c\u5e76\u4e14\u5c3d\u91cf\u63a5\u8fd1199\uff1f \u5373\u6c42\u5927\u4e8e\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6700\u5c0f\u503c\uff0c\u5e76\u4e14\u8f93\u51fa\u4e00\u79cd\u5177\u4f53\u7684\u65b9\u6848\u3002 \u601d\u8def(\u6c42\u5927\u4e8e\u7b49\u4e8e\u76ee\u6807\u503c\u7684\u6700\u5c0f\u503c)\uff1a f[i][j] means whether the former i number can make up j. \u5728new f[n + 1][target + 1] \u65f6\u5c06target\u6269\u5927\u4e24\u500d,f[n + 1][target * 2 + 1] \u4ecef[n][target]\u5f00\u59cb\u5bfb\u627e\uff0c\u82e5\u4e0d\u4e3a\u771f\uff0c\u5219\u5c06target += 1\uff0c\u76f4\u5230f[n][target]\u4e3a\u771f\u3002 \u601d\u8def(\u8f93\u51fa\u4e00\u79cd\u5177\u4f53\u7684\u65b9\u6848)\uff1a \u7528pai[i][j] \u8868\u793a\u62fc\u51faj\u7684\u6700\u540e\u4e00\u4e2a\u6570\u53ef\u4ee5\u662fpai[i][j] Java\u5b9e\u73b0 public class Shopping { public static void shoppingSnacks ( int [] prices , int target ) { int n = prices . length ; if ( n == 0 && target != 0 ) { return ; } boolean [][] f = new boolean [ n + 1 ][ target * 2 + 1 ]; int [][] pai = new int [ n + 1 ][ target * 2 + 1 ]; f [ 0 ][ 0 ] = true ; for ( int i = 1 ; i < f . length ; i ++) { for ( int j = 0 ; j < f [ 0 ]. length ; j ++) { f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - prices [ i - 1 ] >= 0 ) { f [ i ][ j ] = f [ i ][ j ] || f [ i - 1 ][ j - prices [ i - 1 ]]; if ( f [ i - 1 ][ j - prices [ i - 1 ]]) { pai [ i ][ j ] = prices [ i - 1 ]; } } } } // \u9009\u62e9\u4e0d\u5c0f\u4e8e\u76ee\u6807\u503c\u7684\u6700\u5c0f\u503c while (! f [ n ][ target ] && target < f [ 0 ]. length - 1 ) { target ++; } // \u6253\u5370\u8d2d\u7269\u8f66\u6e05\u5355 if ( f [ n ][ target ]) { int p = target ; int q = n ; System . out . println ( p + \" = \" ); while ( p > 0 ) { System . out . println ( pai [ q ][ p ]); p -= pai [ q ][ p ]; q --; while ( pai [ q ][ p ] == 0 && q > 0 ) { q --; } } } else { System . out . println ( \"\u6ca1\u6709\u6ee1\u8db3\u8981\u6c42\u7684\u65b9\u6848\" ); } } } int[] arr = {2, 3, 5},int target = 8;","title":"\u5b9e\u9645\u95ee\u9898"},{"location":"backpack/#backpackii-125","text":"f[i][j] means the maximum value of the former i number making up j. f[i][j] = max{f[i-1][j], f[i-1][j-A[i-1]] + V[i-1] | j-A[i-1] >= 0} \u4ee3\u7801\u5b9e\u73b0 public class BackpackII { public int backPackII ( int m , int [] A , int [] V ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [][] f = new int [ n + 1 ][ m + 1 ]; f [ 0 ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ 0 ][ j ] = - 1 ; } for ( int i = 1 ; i < n + 1 ; i ++){ f [ i ][ 0 ] = 0 ; for ( int j = 1 ; j < m + 1 ; j ++){ f [ i ][ j ] = f [ i - 1 ][ j ]; if ( j - A [ i - 1 ] >= 0 && f [ i - 1 ][ j - A [ i - 1 ]] != - 1 ){ f [ i ][ j ]= Math . max ( f [ i ][ j ], f [ i - 1 ][ j - A [ i - 1 ]]+ V [ i - 1 ]); } } } int res = 0 ; for ( int j = 0 ; j < m + 1 ; j ++){ res = Math . max ( res , f [ n ][ j ]); } return res ; } }","title":"BackpackII 125"},{"location":"backpack/#_2","text":"","title":"\u5b8c\u5168\u80cc\u5305"},{"location":"backpack/#backpackiii-440","text":"f[i] means the maximum value of size i, if f[i] doen't exist,using Integer.MIN_VALUE to represent it. f[i] = max{f[i-A[j]] + V[j]} \u4ee3\u7801\u5b9e\u73b0 public class BackpackIII { public int backPackIII ( int [] A , int [] V , int m ) { int n = A . length ; if ( n == 0 ){ return 0 ; } int [] f = new int [ m + 1 ]; f [ 0 ] = 0 ; for ( int i = 1 ; i < m + 1 ; i ++){ f [ i ] = Integer . MIN_VALUE ; for ( int j = 0 ; j < n ; j ++){ if ( i - A [ j ] >= 0 && f [ i - A [ j ]] + V [ j ] > f [ i ]){ f [ i ] = f [ i - A [ j ]] + V [ j ]; } } } int res = 0 ; for ( int i = 0 ; i < m + 1 ; i ++){ res = Math . max ( res , f [ i ]); } return res ; } }","title":"BackpackIII 440"},{"location":"hashcode/","text":"\u54c8\u5e0c\u8868 \u00b6 547. Intersection of Two Arrays 548. Intersection of Two Arrays II 158. Valid Anagram \u65b9\u6cd51\uff1a\u662f\u7528\u4e00\u4e2amap\u53bb\u5b58\u50a8\uff0c\u5982\u679c\u5b58\u5728\u67d0\u4e2a\u5b57\u7b26\uff0c\u5219value\u51cf1\uff0c\u5f53value\u503c\u4e3a0\u5219\u5220\u9664\u8be5\u5b57\u7b26\uff0c\u6700\u540e\u901a\u8fc7map\u662f\u5426\u4e3a\u7a7a\u6765\u5224\u65ad \u65b9\u6cd52\uff1a\u7528\u54c8\u5e0c\u8868\u5206\u522b\u5b58\u50a8\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\uff0c\u7136\u540e\u4e00\u4e00\u6bd4\u8f83\u4e24\u4e2a\u54c8\u5e0c\u8868\u4e2d\u67d0\u4e2a\u5b57\u7b26\u5bf9\u5e94\u7684value\u662f\u5426\u76f8\u7b49\uff0c\u53ea\u6709\u5168\u90e8\u76f8\u7b49\u624d\u5224\u65ad\u4e3atrue 488.Happy Number 828.Word Pattern -----------\u8003\u8651\u88ab\u8986\u76d6\u7684\u7279\u6b8a\u60c5\u51b5\uff1a\"abba\" and \"dog dog dog dog\"; 638.Isomorphic Strings \u540c\u6784 56. Two Sum 976. 4Sum II 1237. Number of Boomerangs 1320. Contains Duplicate 1319. Contains Duplicate II 1318. Contains Duplicate III 3Sum 4Sum 3Sum Closest Group Anagrams Max Points on a Line","title":"2. \u54c8\u5e0c\u8868"},{"location":"hashcode/#_1","text":"547. Intersection of Two Arrays 548. Intersection of Two Arrays II 158. Valid Anagram \u65b9\u6cd51\uff1a\u662f\u7528\u4e00\u4e2amap\u53bb\u5b58\u50a8\uff0c\u5982\u679c\u5b58\u5728\u67d0\u4e2a\u5b57\u7b26\uff0c\u5219value\u51cf1\uff0c\u5f53value\u503c\u4e3a0\u5219\u5220\u9664\u8be5\u5b57\u7b26\uff0c\u6700\u540e\u901a\u8fc7map\u662f\u5426\u4e3a\u7a7a\u6765\u5224\u65ad \u65b9\u6cd52\uff1a\u7528\u54c8\u5e0c\u8868\u5206\u522b\u5b58\u50a8\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\uff0c\u7136\u540e\u4e00\u4e00\u6bd4\u8f83\u4e24\u4e2a\u54c8\u5e0c\u8868\u4e2d\u67d0\u4e2a\u5b57\u7b26\u5bf9\u5e94\u7684value\u662f\u5426\u76f8\u7b49\uff0c\u53ea\u6709\u5168\u90e8\u76f8\u7b49\u624d\u5224\u65ad\u4e3atrue 488.Happy Number 828.Word Pattern -----------\u8003\u8651\u88ab\u8986\u76d6\u7684\u7279\u6b8a\u60c5\u51b5\uff1a\"abba\" and \"dog dog dog dog\"; 638.Isomorphic Strings \u540c\u6784 56. Two Sum 976. 4Sum II 1237. Number of Boomerangs 1320. Contains Duplicate 1319. Contains Duplicate II 1318. Contains Duplicate III 3Sum 4Sum 3Sum Closest Group Anagrams Max Points on a Line","title":"\u54c8\u5e0c\u8868"},{"location":"hashtable/","text":"\u54c8\u5e0c\u8868O(1) \u00b6 Seperate Chaining(\u94fe\u5730\u5740\u6cd5) \u00b6 \u6570\u7ec4\u4e2d\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5b58\u50a8\u4e00\u4e2a\u94fe\u8868\u6216\u8005TreeMap \u6bd4\u8f83\u4e24\u4e2a\u5bf9\u8c61\u662f\u5426\u76f8\u540c\uff1ahashCode()\u4e0eequals() \u54c8\u5e0c\u51fd\u6570\u7684\u8bbe\u8ba1--------\u201c\u952e\u201d\u8f6c\u6362\u4e3a\u201c\u7d22\u5f15\u201d \u00b6 \u6574\u6570\uff1a\u5c0f\u8303\u56f4\u6b63\u6574\u6570\u76f4\u63a5\u4f7f\u7528\uff0c\u5c0f\u8303\u56f4\u8d1f\u6574\u6570\u8fdb\u884c\u504f\u79fb\uff0c\u5927\u6574\u6570\u53d6\u6a21\u65f6\u53d6\u4e00\u4e2a\u7d20\u6570\uff0c\u80fd\u4f7f\u5206\u5e03\u5747\u5300 \u6d6e\u70b9\u6570\uff1a\u752832\u4f4d\u6216\u800564\u4f4d\u7684\u4e8c\u8fdb\u5236\u8868\u793a\uff0c\u518d\u53d6\u6a21 \u5b57\u7b26\u4e32\uff1a\u4ee5\u5355\u8bcdcode\u4e3a\u4f8b hash(code) = ( c x B^3 + o x B^2 + d x B^1 + e x B^0 ) % M = ((((c % M x B) + o) % M x B + d) % M * B + e) % M \u5b57\u7b26\u4e32 int hash = 0 ; for ( int i = 0 ; i < s . length () ; i ++) { hash = ( hash * B + s . charAt ( i )) % M ; } \u54c8\u5e0c\u51b2\u7a81 \u00b6 \u4e0d\u540c\u7684\u201c\u952e\u201d\u901a\u8fc7\u54c8\u5e0c\u51fd\u6570\u7684\u8f6c\u6362\u5f97\u5230\u4e86\u76f8\u540c\u7684\u7d22\u5f15 \u52a8\u6001\u6269\u5bb9(resize) \u00b6 \u5f53\u5143\u7d20\u4e2a\u6570 >= \u5730\u5740\u6570\u91cf x upper tolerance, \u5219\u9700\u8981\u6269\u5bb9 \u5f53\u5143\u7d20\u4e2a\u6570 < \u5730\u5740\u6570\u91cf x upper tolerance,\u5219\u9700\u8981\u7f29\u5bb9 \u8fd9\u91cc\u7684\u6269\u5bb9\u64cd\u4f5c\u7c7b\u6bd4Array\u52a8\u6001\u6570\u7ec4\u7684\u6269\u5bb9\u64cd\u4f5c\u6709\u6240\u4e0d\u540c\uff0c\u52a8\u6001\u6570\u7ec4\u7684\u6269\u5bb9\u64cd\u4f5c\u53ef\u4ee5\u5728\u539f\u6709\u5bb9\u91cf\u4e0ax2\u5b9e\u73b0\uff0c\u4f46\u54c8\u5e0c\u8868\u7684\u6269\u5bb9\u51fa\u4e8e\u5bf9\u5730\u5740\u6570\u91cf\u4e3a\u7d20\u6570\u7684\u8003\u8651\uff0c\u9700\u8981\u5728\u54c8\u5e0c\u8868\u4e2d\u521b\u5efa\u4e00\u5f20\u7d20\u6570\u8868\uff0c\u5f53\u6269\u5bb9\u65f6\uff0c\u5730\u5740\u6570\u91cf\u53d6\u7d20\u6570\u8868\u7684\u4e0b\u4e00\u4e2a\u503c\u3002 Java\u5b9e\u73b0 import java.util.TreeMap ; public class HashTable < K , V > { private int [] capacity = { 53 , 97 , 193 , 389 , 769 , 1543 , 3079 , 6151 , 12289 , 24593 , 49157 , 98317 , 196613 , 393241 , 786433 , 1572869 , 3145739 , 6291469 , 12582917 , 25165843 , 50331653 , 100663319 , 201326611 , 402653189 , 805306457 , 1610612741 }; private static final int upperTol = 10 ; private static final int lowerTol = 2 ; private int capacityIndex = 0 ; private TreeMap < K , V >[] hashtable ; private int M ; private int size ; @SuppressWarnings ( \"unchecked\" ) public HashTable () { this . M = capacity [ capacityIndex ]; this . size = 0 ; hashtable = new TreeMap [ M ]; for ( int i = 0 ; i < M ; i ++) { hashtable [ i ] = new TreeMap <>(); } } private int hash ( K key ) { return ( key . hashCode () & 0x7fffffff ) % M ; } public int getSize () { return size ; } public void set ( K key , V value ) { TreeMap < K , V > map = hashtable [ hash ( key )]; if (! map . containsKey ( key )) { throw new IllegalArgumentException ( key + \"doesn't exist!\" ); } map . put ( key , value ); } public boolean contains ( K key ) { return hashtable [ hash ( key )]. containsKey ( key ); } public V get ( K key ) { return hashtable [ hash ( key )]. get ( key ); } public void add ( K key , V value ) { TreeMap < K , V > map = hashtable [ hash ( key )]; if ( map . containsKey ( key )) { map . put ( key , value ); } else { map . put ( key , value ); size ++; if ( size >= upperTol * M && capacityIndex + 1 < capacity . length ) { capacityIndex ++; resize ( capacity [ capacityIndex ]); } } } public V remove ( K key ) { TreeMap < K , V > map = hashtable [ hash ( key )]; V ret = null ; if ( map . containsKey ( key )) { ret = map . remove ( key ); size --; if ( size < lowerTol * M && capacityIndex - 1 >= 0 ) { capacityIndex --; resize ( capacity [ capacityIndex ]); } } return ret ; } @SuppressWarnings ( \"unchecked\" ) private void resize ( int newM ) { TreeMap < K , V >[] newHashTable = new TreeMap [ newM ]; for ( int i = 0 ; i < newM ; i ++) { newHashTable [ i ] = new TreeMap <>(); } int oldM = M ; this . M = newM ; for ( int i = 0 ; i < oldM ; i ++) { TreeMap < K , V > map = hashtable [ i ]; for ( K key : map . keySet ()) { newHashTable [ hash ( key )]. put ( key , map . get ( key )); } } hashtable = newHashTable ; } } \u5f00\u653e\u5730\u5740\u6cd5 \u00b6 \u7ebf\u6027\u63a2\u6d4b\uff1a\u5f53\u54c8\u5e0c\u51b2\u7a81\u65f6\uff0c\u4e0d\u65ad\u5f80\u540e\u9762\u76f8\u90bb\u7684\u7a7a\u4f4d\u7f6e\u586b(+1) \u5e73\u65b9\u63a2\u6d4b\uff1a\u5f53\u54c8\u5e0c\u51b2\u7a81\u65f6\uff0c\u4e0d\u65ad\u5f80\u540e\u9762\u7a7a\u4f4d\u7f6e\u586b(+1,+4,+9,+16) \u4e8c\u6b21\u54c8\u5e0c\uff1a\u5f53\u54c8\u5e0c\u51b2\u7a81\u65f6\uff0c\u7528\u53e6\u4e00\u4e2a\u54c8\u5e0c\u51fd\u6570\u5f00\u6765\u9009\u62e9\u4f4d\u7f6e \u5907\u6ce8\uff1a\u5f53\u8d1f\u8f7d\u7387(\u54c8\u5e0c\u8868\u7684\u5143\u7d20\u4e2a\u6570\u5360\u6574\u4e2a\u5730\u5740\u6570\u91cf\u7684\u767e\u5206\u6bd4)\u5230\u8fbe\u4e00\u5b9a\u7a0b\u5ea6\uff0c\u9700\u8981\u6269\u5bb9\u64cd\u4f5c java\u54c8\u5e0c\u8868\u7684\u5e95\u5c42\u5b9e\u73b0 \u00b6 java8\u4ee5\u524d\uff0c\u54c8\u5e0c\u8868\u5e95\u5c42\u901a\u8fc7\u4ee5\u5b58\u50a8\u94fe\u8868\u7684\u6570\u7ec4\u5b9e\u73b0 java8\u5f00\u59cb\uff0c\u5f53\u54c8\u5e0c\u51b2\u7a81\u6bd4\u8f83\u5c0f\u7684\u65f6\u5019\u7528\u94fe\u8868\uff0c\u5f53\u54c8\u5e0c\u51b2\u7a81\u6bd4\u8f83\u5927\u7684\u65f6\u5019\u4f1a\u5c06\u94fe\u8868\u8f6c\u6210\u7ea2\u9ed1\u6811","title":"\u56db. hashtable"},{"location":"hashtable/#o1","text":"","title":"\u54c8\u5e0c\u8868O(1)"},{"location":"hashtable/#seperate-chaining","text":"\u6570\u7ec4\u4e2d\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5b58\u50a8\u4e00\u4e2a\u94fe\u8868\u6216\u8005TreeMap \u6bd4\u8f83\u4e24\u4e2a\u5bf9\u8c61\u662f\u5426\u76f8\u540c\uff1ahashCode()\u4e0eequals()","title":"Seperate  Chaining(\u94fe\u5730\u5740\u6cd5)"},{"location":"hashtable/#-","text":"\u6574\u6570\uff1a\u5c0f\u8303\u56f4\u6b63\u6574\u6570\u76f4\u63a5\u4f7f\u7528\uff0c\u5c0f\u8303\u56f4\u8d1f\u6574\u6570\u8fdb\u884c\u504f\u79fb\uff0c\u5927\u6574\u6570\u53d6\u6a21\u65f6\u53d6\u4e00\u4e2a\u7d20\u6570\uff0c\u80fd\u4f7f\u5206\u5e03\u5747\u5300 \u6d6e\u70b9\u6570\uff1a\u752832\u4f4d\u6216\u800564\u4f4d\u7684\u4e8c\u8fdb\u5236\u8868\u793a\uff0c\u518d\u53d6\u6a21 \u5b57\u7b26\u4e32\uff1a\u4ee5\u5355\u8bcdcode\u4e3a\u4f8b hash(code) = ( c x B^3 + o x B^2 + d x B^1 + e x B^0 ) % M = ((((c % M x B) + o) % M x B + d) % M * B + e) % M \u5b57\u7b26\u4e32 int hash = 0 ; for ( int i = 0 ; i < s . length () ; i ++) { hash = ( hash * B + s . charAt ( i )) % M ; }","title":"\u54c8\u5e0c\u51fd\u6570\u7684\u8bbe\u8ba1--------\u201c\u952e\u201d\u8f6c\u6362\u4e3a\u201c\u7d22\u5f15\u201d"},{"location":"hashtable/#_1","text":"\u4e0d\u540c\u7684\u201c\u952e\u201d\u901a\u8fc7\u54c8\u5e0c\u51fd\u6570\u7684\u8f6c\u6362\u5f97\u5230\u4e86\u76f8\u540c\u7684\u7d22\u5f15","title":"\u54c8\u5e0c\u51b2\u7a81"},{"location":"hashtable/#resize","text":"\u5f53\u5143\u7d20\u4e2a\u6570 >= \u5730\u5740\u6570\u91cf x upper tolerance, \u5219\u9700\u8981\u6269\u5bb9 \u5f53\u5143\u7d20\u4e2a\u6570 < \u5730\u5740\u6570\u91cf x upper tolerance,\u5219\u9700\u8981\u7f29\u5bb9 \u8fd9\u91cc\u7684\u6269\u5bb9\u64cd\u4f5c\u7c7b\u6bd4Array\u52a8\u6001\u6570\u7ec4\u7684\u6269\u5bb9\u64cd\u4f5c\u6709\u6240\u4e0d\u540c\uff0c\u52a8\u6001\u6570\u7ec4\u7684\u6269\u5bb9\u64cd\u4f5c\u53ef\u4ee5\u5728\u539f\u6709\u5bb9\u91cf\u4e0ax2\u5b9e\u73b0\uff0c\u4f46\u54c8\u5e0c\u8868\u7684\u6269\u5bb9\u51fa\u4e8e\u5bf9\u5730\u5740\u6570\u91cf\u4e3a\u7d20\u6570\u7684\u8003\u8651\uff0c\u9700\u8981\u5728\u54c8\u5e0c\u8868\u4e2d\u521b\u5efa\u4e00\u5f20\u7d20\u6570\u8868\uff0c\u5f53\u6269\u5bb9\u65f6\uff0c\u5730\u5740\u6570\u91cf\u53d6\u7d20\u6570\u8868\u7684\u4e0b\u4e00\u4e2a\u503c\u3002 Java\u5b9e\u73b0 import java.util.TreeMap ; public class HashTable < K , V > { private int [] capacity = { 53 , 97 , 193 , 389 , 769 , 1543 , 3079 , 6151 , 12289 , 24593 , 49157 , 98317 , 196613 , 393241 , 786433 , 1572869 , 3145739 , 6291469 , 12582917 , 25165843 , 50331653 , 100663319 , 201326611 , 402653189 , 805306457 , 1610612741 }; private static final int upperTol = 10 ; private static final int lowerTol = 2 ; private int capacityIndex = 0 ; private TreeMap < K , V >[] hashtable ; private int M ; private int size ; @SuppressWarnings ( \"unchecked\" ) public HashTable () { this . M = capacity [ capacityIndex ]; this . size = 0 ; hashtable = new TreeMap [ M ]; for ( int i = 0 ; i < M ; i ++) { hashtable [ i ] = new TreeMap <>(); } } private int hash ( K key ) { return ( key . hashCode () & 0x7fffffff ) % M ; } public int getSize () { return size ; } public void set ( K key , V value ) { TreeMap < K , V > map = hashtable [ hash ( key )]; if (! map . containsKey ( key )) { throw new IllegalArgumentException ( key + \"doesn't exist!\" ); } map . put ( key , value ); } public boolean contains ( K key ) { return hashtable [ hash ( key )]. containsKey ( key ); } public V get ( K key ) { return hashtable [ hash ( key )]. get ( key ); } public void add ( K key , V value ) { TreeMap < K , V > map = hashtable [ hash ( key )]; if ( map . containsKey ( key )) { map . put ( key , value ); } else { map . put ( key , value ); size ++; if ( size >= upperTol * M && capacityIndex + 1 < capacity . length ) { capacityIndex ++; resize ( capacity [ capacityIndex ]); } } } public V remove ( K key ) { TreeMap < K , V > map = hashtable [ hash ( key )]; V ret = null ; if ( map . containsKey ( key )) { ret = map . remove ( key ); size --; if ( size < lowerTol * M && capacityIndex - 1 >= 0 ) { capacityIndex --; resize ( capacity [ capacityIndex ]); } } return ret ; } @SuppressWarnings ( \"unchecked\" ) private void resize ( int newM ) { TreeMap < K , V >[] newHashTable = new TreeMap [ newM ]; for ( int i = 0 ; i < newM ; i ++) { newHashTable [ i ] = new TreeMap <>(); } int oldM = M ; this . M = newM ; for ( int i = 0 ; i < oldM ; i ++) { TreeMap < K , V > map = hashtable [ i ]; for ( K key : map . keySet ()) { newHashTable [ hash ( key )]. put ( key , map . get ( key )); } } hashtable = newHashTable ; } }","title":"\u52a8\u6001\u6269\u5bb9(resize)"},{"location":"hashtable/#_2","text":"\u7ebf\u6027\u63a2\u6d4b\uff1a\u5f53\u54c8\u5e0c\u51b2\u7a81\u65f6\uff0c\u4e0d\u65ad\u5f80\u540e\u9762\u76f8\u90bb\u7684\u7a7a\u4f4d\u7f6e\u586b(+1) \u5e73\u65b9\u63a2\u6d4b\uff1a\u5f53\u54c8\u5e0c\u51b2\u7a81\u65f6\uff0c\u4e0d\u65ad\u5f80\u540e\u9762\u7a7a\u4f4d\u7f6e\u586b(+1,+4,+9,+16) \u4e8c\u6b21\u54c8\u5e0c\uff1a\u5f53\u54c8\u5e0c\u51b2\u7a81\u65f6\uff0c\u7528\u53e6\u4e00\u4e2a\u54c8\u5e0c\u51fd\u6570\u5f00\u6765\u9009\u62e9\u4f4d\u7f6e \u5907\u6ce8\uff1a\u5f53\u8d1f\u8f7d\u7387(\u54c8\u5e0c\u8868\u7684\u5143\u7d20\u4e2a\u6570\u5360\u6574\u4e2a\u5730\u5740\u6570\u91cf\u7684\u767e\u5206\u6bd4)\u5230\u8fbe\u4e00\u5b9a\u7a0b\u5ea6\uff0c\u9700\u8981\u6269\u5bb9\u64cd\u4f5c","title":"\u5f00\u653e\u5730\u5740\u6cd5"},{"location":"hashtable/#java","text":"java8\u4ee5\u524d\uff0c\u54c8\u5e0c\u8868\u5e95\u5c42\u901a\u8fc7\u4ee5\u5b58\u50a8\u94fe\u8868\u7684\u6570\u7ec4\u5b9e\u73b0 java8\u5f00\u59cb\uff0c\u5f53\u54c8\u5e0c\u51b2\u7a81\u6bd4\u8f83\u5c0f\u7684\u65f6\u5019\u7528\u94fe\u8868\uff0c\u5f53\u54c8\u5e0c\u51b2\u7a81\u6bd4\u8f83\u5927\u7684\u65f6\u5019\u4f1a\u5c06\u94fe\u8868\u8f6c\u6210\u7ea2\u9ed1\u6811","title":"java\u54c8\u5e0c\u8868\u7684\u5e95\u5c42\u5b9e\u73b0"},{"location":"linear/","text":"\u7ebf\u6027\u6570\u636e\u7ed3\u6784 \u00b6 Array(\u52a8\u6001\u6570\u7ec4) \u00b6 Java\u5b9e\u73b0 public class Array < E > { private E [] data ; private int size ; @SuppressWarnings ( \"unchecked\" ) public Array ( int capacity ) { data = ( E []) new Object [ capacity ]; size = 0 ; } public Array () { this ( 10 ); } @SuppressWarnings ( \"unchecked\" ) public Array ( E [] arr ) { data = ( E []) new Object [ arr . length ]; for ( int i = 0 ; i < arr . length ; i ++) { data [ i ] = arr [ i ]; } size = arr . length ; } public int getSize () { return size ; } public int getCapacity () { return data . length ; } public boolean isEmpty () { return size == 0 ; } public void add ( int index , E e ) { if ( index < 0 || index > size ) { throw new IllegalArgumentException ( \"Add failed.Illegal index.\" ); } if ( size == data . length ) { resize ( 2 * data . length ); } if ( index < size ) { for ( int i = size - 1 ; i >= index ; i --) { data [ i + 1 ] = data [ i ]; } } data [ index ] = e ; size ++; } public void addFirst ( E e ) { add ( 0 , e ); } public void addLast ( E e ) { add ( size , e ); } public E get ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"Get failed.Illegal index.\" ); } return data [ index ]; } public E getFirst () { return get ( 0 ); } public E getLast () { return get ( size - 1 ); } public void set ( int index , E e ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"Set failed.Illegal index.\" ); } data [ index ] = e ; } public boolean contains ( E e ) { for ( int i = 0 ; i < size ; i ++) { if ( data [ i ]. equals ( e )) { return true ; } } return false ; } public int find ( E e ) { for ( int i = 0 ; i < size ; i ++) { if ( data [ i ]. equals ( e )) { return i ; } } return - 1 ; } public E remove ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"Remove failed.Illegal index.\" ); } E ret = data [ index ]; for ( int i = index + 1 ; i < size ; i ++) { data [ i - 1 ] = data [ i ]; } data [-- size ] = null ; if ( size == data . length / 4 && data . length / 2 != 0 ) { resize ( data . length / 2 ); } return ret ; } public E removeFirst () { return remove ( 0 ); } public E removeLast () { return remove ( size - 1 ); } public void resize ( int newCapacity ) { @SuppressWarnings ( \"unchecked\" ) E [] newData = ( E []) new Object [ newCapacity ]; for ( int i = 0 ; i < size ; i ++) { newData [ i ] = data [ i ]; } data = newData ; } public String toString () { StringBuilder sb = new StringBuilder (); sb . append ( String . format ( \"Array: size = %d, capacity = %d\\n\" , size , data . length )); sb . append ( \"[\" ); for ( int i = 0 ; i < size ; i ++) { sb . append ( data [ i ]); if ( i != size - 1 ) { sb . append ( \", \" ); } } sb . append ( \"]\" ); return sb . toString (); } } \u7c7b\u6bd4Java\u4e2d\u7684ArrayList,\u4f46ArrayList\u7684\u6269\u5bb9\u662f\u4e58\u4ee51.5\u500d method time complexity add O(n) addFirst O(n) addLast O(1) remove O(n) removeFirst O(n) removeLast O(1) set O(1) get O(1) getFirst O(1) getLast O(1) resize O(1)\u5747\u644a LinkedList \u00b6 java\u5b9e\u73b0(\u542b\u6709\u865a\u62df\u5934\u7ed3\u70b9) public class LinkedList < E > { private class Node { private E e ; private Node next ; public Node ( E e , Node next ) { this . e = e ; this . next = next ; } public String toString () { return e . toString (); } } private Node dummyHead ; private int size ; public LinkedList () { dummyHead = new Node ( null , null ); size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( int index , E e ) { if ( index < 0 || index > size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node prev = dummyHead ; for ( int i = 0 ; i < index ; i ++) { prev = prev . next ; } prev . next = new Node ( e , prev . next ); size ++; } public void addFirst ( E e ) { add ( 0 , e ); } public void addLast ( E e ) { add ( size , e ); } public E get ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = dummyHead . next ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } return cur . e ; } public E getFirst () { return get ( 0 ); } public E getLast () { return get ( size - 1 ); } public void set ( int index , E e ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = dummyHead . next ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } cur . e = e ; } public boolean contains ( E e ) { Node cur = dummyHead . next ; while ( cur != null ) { if ( cur . e . equals ( e )) { return true ; } cur = cur . next ; } return false ; } public E remove ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node prev = dummyHead ; for ( int i = 0 ; i < index ; i ++) { prev = prev . next ; } Node delNode = prev . next ; prev . next = delNode . next ; delNode . next = null ; size --; return delNode . e ; } public E removeFirst () { return remove ( 0 ); } public E removeLast () { return remove ( size - 1 ); } public String toString () { StringBuilder ret = new StringBuilder (); Node cur = dummyHead . next ; while ( cur != null ) { ret . append ( cur . e ); ret . append ( \"-->\" ); cur = cur . next ; } ret . append ( \"NULL\" ); return ret . toString (); } } \u7c7b\u6bd4Java\u4e2d\u7684LinkedList, \u4f46Java\u4e2d\u7684LinkedList\u91c7\u7528\u4e86\u53cc\u6307\u9488 method time complexity add: O(n) addFirst: O(1) addLast: O(n) remove: O(n) removeFirst: O(1) removeLast: O(n) set: O(n) get: O(n) getFirst: O(1) getLast: O(n) resize: O(1)\u5747\u644a Stack \u00b6 \u5bf9\u4e8eStack\u800c\u8a00\uff0c\u65e0\u8bba\u662f\u7528\u52a8\u6001\u6570\u7ec4\u5b9e\u73b0\u7684\u6808\u8fd8\u662f\u7528\u94fe\u8868\u5b9e\u73b0\u7684\u6808\uff0c\u90fd\u53ef\u4ee5\u505a\u5230\u5165\u6808\u548c\u51fa\u6808\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(1) \u770bJava\u7684\u6e90\u4ee3\u7801\u53d1\u73b0\uff0cJava\u4e2d\u7684Stack\u662f\u57fa\u4e8eVector\u52a8\u6001\u6570\u7ec4\u5b9e\u73b0\u7684\uff0cVector\u548cArrayList\u7684\u533a\u522b\u5728\u4e8eVector\u5bf9\u5143\u7d20\u7684\u8bbf\u95ee\u90fd\u7528synchronized(\u540c\u6b65)\u4fee\u9970\uff0c\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0cVector,ArrayList\u548cLinkedLis\u5171\u540c\u5b9e\u73b0\u4e86List\u96c6\u5408\u63a5\u53e3\u3002 Queue \u00b6 Queue\u63a5\u53e3 public interface Queue < E > { int getSize (); boolean isEmpty (); void enqueue ( E e ); E dequeue (); E getFront (); } \u5bf9\u4e8eQueue\u800c\u8a00\uff0c\u52a8\u6001\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217\u5728\u5165\u961f\u4e0a\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(1),\u4f46\u5728\u51fa\u961f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n),\u8fd9\u65f6\u53ef\u4ee5\u8003\u8651\u7528\u57fa\u4e8e\u52a8\u6001\u6570\u7ec4\u7684\u5faa\u73af\u961f\u5217LoopQueue+\u53cc\u6307\u9488(front,tail\uff0c\u5176\u4e2dtail\u6307\u9488\u505c\u7559\u5728\u4e0b\u4e00\u4e2a\u9700\u8981\u5165\u961f\u7684\u4f4d\u7f6e)\u5b9e\u73b0\u5165\u961f\u548c\u51fa\u961f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u4e3aO(1),\u5f53front = tail\u65f6\u8868\u793a\u961f\u5217\u4e3a\u7a7a\uff0c\u5f53tail + 1 = front\u65f6\u8868\u793a\u961f\u5217\u6ee1\u4e86\uff0c\u4e3a\u6b64\u9700\u8981\u989d\u5916\u7559\u7a7a\u4e00\u4e2a\u7a7a\u95f4\uff1b LoopQueue public class LoopQueue < E > implements Queue < E > { private E [] data ; private int front ; private int tail ; private int size ; @SuppressWarnings ( \"unchecked\" ) public LoopQueue ( int capacity ) { data = ( E []) new Object [ capacity + 1 ]; front = 0 ; tail = 0 ; size = 0 ; } public LoopQueue () { this ( 10 ); } public int getCapacity () { return data . length - 1 ; } public int getSize () { return size ; } public boolean isEmpty () { return front == tail ; } public void enqueue ( E e ) { if (( tail + 1 ) % data . length == front ) { resize ( getCapacity () * 2 ); } data [ tail ] = e ; tail = ( tail + 1 ) % data . length ; size ++; } @SuppressWarnings ( \"unchecked\" ) private void resize ( int newCapacity ) { E [] newData = ( E []) new Object [ newCapacity + 1 ]; for ( int i = 0 ; i < size ; i ++) { newData [ i ] = data [( i + front ) % data . length ]; } data = newData ; front = 0 ; tail = size ; } public E dequeue () { if ( isEmpty ()) { throw new IllegalArgumentException ( \"Can not pop from an empty Queue\" ); } E ret = data [ front ]; data [ front ] = null ; front = ( front + 1 ) % data . length ; size --; if ( size == getCapacity () / 4 && getCapacity () / 2 != 0 ) { resize ( getCapacity () / 2 ); } return ret ; } public E getFront () { if ( isEmpty ()) { throw new IllegalArgumentException ( \"Can not peek from an empty Queue\" ); } return data [ front ]; } public String toString () { StringBuilder ret = new StringBuilder (); ret . append ( \"front [\" ); for ( int i = front ; i != tail ; i = ( i + 1 ) % data . length ) { ret . append ( data [ i ]); if (( i + 1 ) % data . length != tail ) { ret . append ( \", \" ); } } ret . append ( \"] tail\" ); return ret . toString (); } } \u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217\u5728\u5165\u961f\u4e0a\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n),\u5728\u51fa\u961f\u4e0a\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(1),\u8fd9\u65f6\u8003\u8651\u4fee\u6539\u94fe\u8868\uff0c\u52a0\u5165\u53cc\u6307\u9488(head,tail),\u53ef\u4ee5\u5b9e\u73b0\u5165\u961f\u548c\u51fa\u961f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u8fbe\u5230O(1) LinkedList(\u53cc\u6307\u9488) public class LinkedList < E > { private class Node { private E e ; private Node next ; public Node ( E e , Node next ) { this . e = e ; this . next = next ; } public String toString () { return e . toString (); } } private Node head ; private Node tail ; private int size ; public LinkedList () { head = null ; tail = null ; size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( int index , E e ) { if ( index < 0 || index > size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } if ( size == 0 ) { head = tail = new Node ( e , null ); size ++; return ; } if ( index == 0 ) { Node cur = head ; head = new Node ( e , cur ); } else if ( index == size ) { tail . next = new Node ( e , null ); tail = tail . next ; } else { Node cur = head ; for ( int i = 0 ; i < index - 1 ; i ++) { cur = cur . next ; } cur . next = new Node ( e , cur . next ); } size ++; } public void addFirst ( E e ) { add ( 0 , e ); } public void addLast ( E e ) { add ( size , e ); } public E get ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = head ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } return cur . e ; } public E getFirst () { return get ( 0 ); } public E getLast () { return get ( size - 1 ); } public void set ( int index , E e ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = head ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } cur . e = e ; } public boolean contains ( E e ) { Node cur = head ; while ( cur != null ) { if ( cur . e . equals ( e )) { return true ; } cur = cur . next ; } return false ; } public E remove ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } E ret = get ( index ); if ( size == 1 ) { head = tail = null ; size --; return ret ; } if ( index == 0 ) { head = head . next ; } else if ( index == size - 1 ) { Node cur = head ; for ( int i = 0 ; i < index - 1 ; i ++) { cur = cur . next ; } tail = cur ; tail . next = null ; } else { Node cur = head ; for ( int i = 0 ; i < index - 1 ; i ++) { cur = cur . next ; } Node delNode = cur . next ; cur . next = delNode . next ; delNode . next = null ; } size --; return ret ; } public E removeFirst () { return remove ( 0 ); } public E removeLast () { return remove ( size - 1 ); } public String toString () { StringBuilder ret = new StringBuilder (); Node cur = head ; while ( cur != null ) { ret . append ( cur . e ); ret . append ( \"-->\" ); cur = cur . next ; } ret . append ( \"NULL\" ); return ret . toString (); } } LinkedListQueue public class LinkedListQueue < E > implements Queue < E > { private LinkedList < E > list ; public LinkedListQueue () { list = new LinkedList <>(); } public int getSize () { return list . getSize (); } public boolean isEmpty () { return list . isEmpty (); } public void enqueue ( E e ) { list . addLast ( e ); } public E dequeue () { return list . removeFirst (); } public E getFront () { return list . getFirst (); } public String toString () { StringBuilder ret = new StringBuilder (); ret . append ( \"top front [\" ); ret . append ( list ); ret . append ( \"] tail\" ); return ret . toString (); } } \u770bJava\u7684\u6e90\u4ee3\u7801\u53d1\u73b0\uff0cJava\u4e2d\u7684Queue\u662f\u57fa\u4e8e\u53cc\u6307\u9488\u7684LinkedList\u5b9e\u73b0\u7684\u3002 PriorityQueue \u00b6 Java public class PriorityQueue < E extends Comparable < E >> implements Queue < E > { private MaxHeap < E > maxHeap ; public PriorityQueue () { maxHeap = new MaxHeap <>(); } public int getSize () { return maxHeap . size (); } public boolean isEmpty () { return maxHeap . isEmpty (); } public void enqueue ( E e ) { maxHeap . add ( e ); } public E dequeue () { return maxHeap . extractMax (); } public E getFront () { return maxHeap . findMax (); } } \u770bJava\u7684\u6e90\u4ee3\u7801\u53d1\u73b0\uff0cJava\u4e2d\u7684PriorityQueue\u662f\u57fa\u4e8e\u6700\u5c0f\u5806\u5b9e\u73b0\u7684\u3002","title":"\u4e8c. Linear Structure"},{"location":"linear/#_1","text":"","title":"\u7ebf\u6027\u6570\u636e\u7ed3\u6784"},{"location":"linear/#array","text":"Java\u5b9e\u73b0 public class Array < E > { private E [] data ; private int size ; @SuppressWarnings ( \"unchecked\" ) public Array ( int capacity ) { data = ( E []) new Object [ capacity ]; size = 0 ; } public Array () { this ( 10 ); } @SuppressWarnings ( \"unchecked\" ) public Array ( E [] arr ) { data = ( E []) new Object [ arr . length ]; for ( int i = 0 ; i < arr . length ; i ++) { data [ i ] = arr [ i ]; } size = arr . length ; } public int getSize () { return size ; } public int getCapacity () { return data . length ; } public boolean isEmpty () { return size == 0 ; } public void add ( int index , E e ) { if ( index < 0 || index > size ) { throw new IllegalArgumentException ( \"Add failed.Illegal index.\" ); } if ( size == data . length ) { resize ( 2 * data . length ); } if ( index < size ) { for ( int i = size - 1 ; i >= index ; i --) { data [ i + 1 ] = data [ i ]; } } data [ index ] = e ; size ++; } public void addFirst ( E e ) { add ( 0 , e ); } public void addLast ( E e ) { add ( size , e ); } public E get ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"Get failed.Illegal index.\" ); } return data [ index ]; } public E getFirst () { return get ( 0 ); } public E getLast () { return get ( size - 1 ); } public void set ( int index , E e ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"Set failed.Illegal index.\" ); } data [ index ] = e ; } public boolean contains ( E e ) { for ( int i = 0 ; i < size ; i ++) { if ( data [ i ]. equals ( e )) { return true ; } } return false ; } public int find ( E e ) { for ( int i = 0 ; i < size ; i ++) { if ( data [ i ]. equals ( e )) { return i ; } } return - 1 ; } public E remove ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"Remove failed.Illegal index.\" ); } E ret = data [ index ]; for ( int i = index + 1 ; i < size ; i ++) { data [ i - 1 ] = data [ i ]; } data [-- size ] = null ; if ( size == data . length / 4 && data . length / 2 != 0 ) { resize ( data . length / 2 ); } return ret ; } public E removeFirst () { return remove ( 0 ); } public E removeLast () { return remove ( size - 1 ); } public void resize ( int newCapacity ) { @SuppressWarnings ( \"unchecked\" ) E [] newData = ( E []) new Object [ newCapacity ]; for ( int i = 0 ; i < size ; i ++) { newData [ i ] = data [ i ]; } data = newData ; } public String toString () { StringBuilder sb = new StringBuilder (); sb . append ( String . format ( \"Array: size = %d, capacity = %d\\n\" , size , data . length )); sb . append ( \"[\" ); for ( int i = 0 ; i < size ; i ++) { sb . append ( data [ i ]); if ( i != size - 1 ) { sb . append ( \", \" ); } } sb . append ( \"]\" ); return sb . toString (); } } \u7c7b\u6bd4Java\u4e2d\u7684ArrayList,\u4f46ArrayList\u7684\u6269\u5bb9\u662f\u4e58\u4ee51.5\u500d method time complexity add O(n) addFirst O(n) addLast O(1) remove O(n) removeFirst O(n) removeLast O(1) set O(1) get O(1) getFirst O(1) getLast O(1) resize O(1)\u5747\u644a","title":"Array(\u52a8\u6001\u6570\u7ec4)"},{"location":"linear/#linkedlist","text":"java\u5b9e\u73b0(\u542b\u6709\u865a\u62df\u5934\u7ed3\u70b9) public class LinkedList < E > { private class Node { private E e ; private Node next ; public Node ( E e , Node next ) { this . e = e ; this . next = next ; } public String toString () { return e . toString (); } } private Node dummyHead ; private int size ; public LinkedList () { dummyHead = new Node ( null , null ); size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( int index , E e ) { if ( index < 0 || index > size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node prev = dummyHead ; for ( int i = 0 ; i < index ; i ++) { prev = prev . next ; } prev . next = new Node ( e , prev . next ); size ++; } public void addFirst ( E e ) { add ( 0 , e ); } public void addLast ( E e ) { add ( size , e ); } public E get ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = dummyHead . next ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } return cur . e ; } public E getFirst () { return get ( 0 ); } public E getLast () { return get ( size - 1 ); } public void set ( int index , E e ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = dummyHead . next ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } cur . e = e ; } public boolean contains ( E e ) { Node cur = dummyHead . next ; while ( cur != null ) { if ( cur . e . equals ( e )) { return true ; } cur = cur . next ; } return false ; } public E remove ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node prev = dummyHead ; for ( int i = 0 ; i < index ; i ++) { prev = prev . next ; } Node delNode = prev . next ; prev . next = delNode . next ; delNode . next = null ; size --; return delNode . e ; } public E removeFirst () { return remove ( 0 ); } public E removeLast () { return remove ( size - 1 ); } public String toString () { StringBuilder ret = new StringBuilder (); Node cur = dummyHead . next ; while ( cur != null ) { ret . append ( cur . e ); ret . append ( \"-->\" ); cur = cur . next ; } ret . append ( \"NULL\" ); return ret . toString (); } } \u7c7b\u6bd4Java\u4e2d\u7684LinkedList, \u4f46Java\u4e2d\u7684LinkedList\u91c7\u7528\u4e86\u53cc\u6307\u9488 method time complexity add: O(n) addFirst: O(1) addLast: O(n) remove: O(n) removeFirst: O(1) removeLast: O(n) set: O(n) get: O(n) getFirst: O(1) getLast: O(n) resize: O(1)\u5747\u644a","title":"LinkedList"},{"location":"linear/#stack","text":"\u5bf9\u4e8eStack\u800c\u8a00\uff0c\u65e0\u8bba\u662f\u7528\u52a8\u6001\u6570\u7ec4\u5b9e\u73b0\u7684\u6808\u8fd8\u662f\u7528\u94fe\u8868\u5b9e\u73b0\u7684\u6808\uff0c\u90fd\u53ef\u4ee5\u505a\u5230\u5165\u6808\u548c\u51fa\u6808\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(1) \u770bJava\u7684\u6e90\u4ee3\u7801\u53d1\u73b0\uff0cJava\u4e2d\u7684Stack\u662f\u57fa\u4e8eVector\u52a8\u6001\u6570\u7ec4\u5b9e\u73b0\u7684\uff0cVector\u548cArrayList\u7684\u533a\u522b\u5728\u4e8eVector\u5bf9\u5143\u7d20\u7684\u8bbf\u95ee\u90fd\u7528synchronized(\u540c\u6b65)\u4fee\u9970\uff0c\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff0cVector,ArrayList\u548cLinkedLis\u5171\u540c\u5b9e\u73b0\u4e86List\u96c6\u5408\u63a5\u53e3\u3002","title":"Stack"},{"location":"linear/#queue","text":"Queue\u63a5\u53e3 public interface Queue < E > { int getSize (); boolean isEmpty (); void enqueue ( E e ); E dequeue (); E getFront (); } \u5bf9\u4e8eQueue\u800c\u8a00\uff0c\u52a8\u6001\u6570\u7ec4\u5b9e\u73b0\u7684\u961f\u5217\u5728\u5165\u961f\u4e0a\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(1),\u4f46\u5728\u51fa\u961f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n),\u8fd9\u65f6\u53ef\u4ee5\u8003\u8651\u7528\u57fa\u4e8e\u52a8\u6001\u6570\u7ec4\u7684\u5faa\u73af\u961f\u5217LoopQueue+\u53cc\u6307\u9488(front,tail\uff0c\u5176\u4e2dtail\u6307\u9488\u505c\u7559\u5728\u4e0b\u4e00\u4e2a\u9700\u8981\u5165\u961f\u7684\u4f4d\u7f6e)\u5b9e\u73b0\u5165\u961f\u548c\u51fa\u961f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u4e3aO(1),\u5f53front = tail\u65f6\u8868\u793a\u961f\u5217\u4e3a\u7a7a\uff0c\u5f53tail + 1 = front\u65f6\u8868\u793a\u961f\u5217\u6ee1\u4e86\uff0c\u4e3a\u6b64\u9700\u8981\u989d\u5916\u7559\u7a7a\u4e00\u4e2a\u7a7a\u95f4\uff1b LoopQueue public class LoopQueue < E > implements Queue < E > { private E [] data ; private int front ; private int tail ; private int size ; @SuppressWarnings ( \"unchecked\" ) public LoopQueue ( int capacity ) { data = ( E []) new Object [ capacity + 1 ]; front = 0 ; tail = 0 ; size = 0 ; } public LoopQueue () { this ( 10 ); } public int getCapacity () { return data . length - 1 ; } public int getSize () { return size ; } public boolean isEmpty () { return front == tail ; } public void enqueue ( E e ) { if (( tail + 1 ) % data . length == front ) { resize ( getCapacity () * 2 ); } data [ tail ] = e ; tail = ( tail + 1 ) % data . length ; size ++; } @SuppressWarnings ( \"unchecked\" ) private void resize ( int newCapacity ) { E [] newData = ( E []) new Object [ newCapacity + 1 ]; for ( int i = 0 ; i < size ; i ++) { newData [ i ] = data [( i + front ) % data . length ]; } data = newData ; front = 0 ; tail = size ; } public E dequeue () { if ( isEmpty ()) { throw new IllegalArgumentException ( \"Can not pop from an empty Queue\" ); } E ret = data [ front ]; data [ front ] = null ; front = ( front + 1 ) % data . length ; size --; if ( size == getCapacity () / 4 && getCapacity () / 2 != 0 ) { resize ( getCapacity () / 2 ); } return ret ; } public E getFront () { if ( isEmpty ()) { throw new IllegalArgumentException ( \"Can not peek from an empty Queue\" ); } return data [ front ]; } public String toString () { StringBuilder ret = new StringBuilder (); ret . append ( \"front [\" ); for ( int i = front ; i != tail ; i = ( i + 1 ) % data . length ) { ret . append ( data [ i ]); if (( i + 1 ) % data . length != tail ) { ret . append ( \", \" ); } } ret . append ( \"] tail\" ); return ret . toString (); } } \u94fe\u8868\u5b9e\u73b0\u7684\u961f\u5217\u5728\u5165\u961f\u4e0a\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n),\u5728\u51fa\u961f\u4e0a\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(1),\u8fd9\u65f6\u8003\u8651\u4fee\u6539\u94fe\u8868\uff0c\u52a0\u5165\u53cc\u6307\u9488(head,tail),\u53ef\u4ee5\u5b9e\u73b0\u5165\u961f\u548c\u51fa\u961f\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u8fbe\u5230O(1) LinkedList(\u53cc\u6307\u9488) public class LinkedList < E > { private class Node { private E e ; private Node next ; public Node ( E e , Node next ) { this . e = e ; this . next = next ; } public String toString () { return e . toString (); } } private Node head ; private Node tail ; private int size ; public LinkedList () { head = null ; tail = null ; size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( int index , E e ) { if ( index < 0 || index > size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } if ( size == 0 ) { head = tail = new Node ( e , null ); size ++; return ; } if ( index == 0 ) { Node cur = head ; head = new Node ( e , cur ); } else if ( index == size ) { tail . next = new Node ( e , null ); tail = tail . next ; } else { Node cur = head ; for ( int i = 0 ; i < index - 1 ; i ++) { cur = cur . next ; } cur . next = new Node ( e , cur . next ); } size ++; } public void addFirst ( E e ) { add ( 0 , e ); } public void addLast ( E e ) { add ( size , e ); } public E get ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = head ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } return cur . e ; } public E getFirst () { return get ( 0 ); } public E getLast () { return get ( size - 1 ); } public void set ( int index , E e ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } Node cur = head ; for ( int i = 0 ; i < index ; i ++) { cur = cur . next ; } cur . e = e ; } public boolean contains ( E e ) { Node cur = head ; while ( cur != null ) { if ( cur . e . equals ( e )) { return true ; } cur = cur . next ; } return false ; } public E remove ( int index ) { if ( index < 0 || index >= size ) { throw new IllegalArgumentException ( \"index is illegal\" ); } E ret = get ( index ); if ( size == 1 ) { head = tail = null ; size --; return ret ; } if ( index == 0 ) { head = head . next ; } else if ( index == size - 1 ) { Node cur = head ; for ( int i = 0 ; i < index - 1 ; i ++) { cur = cur . next ; } tail = cur ; tail . next = null ; } else { Node cur = head ; for ( int i = 0 ; i < index - 1 ; i ++) { cur = cur . next ; } Node delNode = cur . next ; cur . next = delNode . next ; delNode . next = null ; } size --; return ret ; } public E removeFirst () { return remove ( 0 ); } public E removeLast () { return remove ( size - 1 ); } public String toString () { StringBuilder ret = new StringBuilder (); Node cur = head ; while ( cur != null ) { ret . append ( cur . e ); ret . append ( \"-->\" ); cur = cur . next ; } ret . append ( \"NULL\" ); return ret . toString (); } } LinkedListQueue public class LinkedListQueue < E > implements Queue < E > { private LinkedList < E > list ; public LinkedListQueue () { list = new LinkedList <>(); } public int getSize () { return list . getSize (); } public boolean isEmpty () { return list . isEmpty (); } public void enqueue ( E e ) { list . addLast ( e ); } public E dequeue () { return list . removeFirst (); } public E getFront () { return list . getFirst (); } public String toString () { StringBuilder ret = new StringBuilder (); ret . append ( \"top front [\" ); ret . append ( list ); ret . append ( \"] tail\" ); return ret . toString (); } } \u770bJava\u7684\u6e90\u4ee3\u7801\u53d1\u73b0\uff0cJava\u4e2d\u7684Queue\u662f\u57fa\u4e8e\u53cc\u6307\u9488\u7684LinkedList\u5b9e\u73b0\u7684\u3002","title":"Queue"},{"location":"linear/#priorityqueue","text":"Java public class PriorityQueue < E extends Comparable < E >> implements Queue < E > { private MaxHeap < E > maxHeap ; public PriorityQueue () { maxHeap = new MaxHeap <>(); } public int getSize () { return maxHeap . size (); } public boolean isEmpty () { return maxHeap . isEmpty (); } public void enqueue ( E e ) { maxHeap . add ( e ); } public E dequeue () { return maxHeap . extractMax (); } public E getFront () { return maxHeap . findMax (); } } \u770bJava\u7684\u6e90\u4ee3\u7801\u53d1\u73b0\uff0cJava\u4e2d\u7684PriorityQueue\u662f\u57fa\u4e8e\u6700\u5c0f\u5806\u5b9e\u73b0\u7684\u3002","title":"PriorityQueue"},{"location":"linkedlist/","text":"\u94fe\u8868 \u00b6 35. Reverse Linked List 36. Reverse Linked List II \u89e3\u6790 \u4e3a\u4e86\u5b9e\u73b0\u5728\u67d0\u4e00\u6bb5[m, n]\u4e0a\u7ffb\u8f6c\u987a\u5e8f\uff0c\u9996\u5148\u8bbe\u7f6e\u865a\u62df\u5934\u7ed3\u70b9\uff0c\u627e\u5230m\u7684\u524d\u4e00\u4e2a\u7ed3\u70b9preNode\uff0c curNode = preNode.next \u83b7\u53d6\u5f53\u524d\u7ed3\u70b9 postNode = curNode.next \u8d1f\u8d23\u79fb\u52a8 \u4f8b\u5982 3->1->4->2->6->7->9->3 \u5728[3,5]\u4e0a\u7ffb\u8f6c\uff0c ListNode dummy = new ListNode ( 0 ); dummy . next = head ; head = dummy ; //\u5728head\u524d\u9762\u63a5\u4e86\u4e00\u4e2a\u865a\u62df\u5934\u7ed3\u70b9 for ( int i = 1 ; i < m ; i ++) { head = head . next ; } ListNode preNode = head ; ListNode curNode = preNode . next ; ListNode postNode = curNode . next ; for ( int i = 0 ; i < n - m ; i ++) { curNode . next = postNode . next ; postNode . next = preNode . next ; preNode . next = postNode ; postNode = curNode . next ; } 112. Remove Duplicates from Sorted List 96. Partition List 1292. Odd Even Linked List \u65b9\u6cd5\u4e00\uff1a \u501f\u9274221\u9898\u7684\u601d\u8def\uff0c\u5229\u7528Queue\u7684FIFO\u539f\u7406\u5c06\u6bcf\u4e2a\u6570\u5b57\u5206\u522b\u5b58\u50a8\u5230\u961f\u5217\u4e2d\uff0c\u518d\u5c06\u961f\u5217\u4e2d\u7684\u6570\u636e\u53d6\u51fa\u8f6c\u5316\u6210\u94fe\u8868 \u65b9\u6cd5\u4e8c\uff1a\u5f00\u59cb\u65f6\u82e5 head,head.next,head.next.next \u90fd\u4e3a\u7a7a\u65f6\u5219\u76f4\u63a5\u8fd4\u56dehead\uff0c\u518d\u540e\u7eed\u5224\u65ad\u4e2dcur,cur.next,cur.next.next\u90fd\u4e3a\u7a7a\u65f6\u5219\u4e0d\u6267\u884c\u4e0b\u53bb 167. Add Two Numbers \u5148\u5206\u522b\u8ba1\u7b97\u51fa\u4e24\u4e2a\u6570\uff0c\u518d\u8ba1\u7b97\u5176\u548c\uff0c\u7136\u540e\u518d\u62c6\u5206\u6210\u94fe\u8868\u7684\u65b9\u6cd5\u4e0d\u53ef\u884c\uff0c\u56e0\u4e3a\u5176\u548c\u4f1a\u8d85\u51faint\u7c7b\u578b\u7684\u8303\u56f4 221. Add Two Numbers II \u5229\u7528Stack\u7684FILO\u539f\u7406\u5c06\u6bcf\u4e2a\u6570\u5b57\u5b58\u50a8\u5230\u4e00\u4e2a\u6808\u4e2d\uff0c\u518d\u5c06\u6808\u4e2d\u7684\u6570\u636e\u53d6\u51fa\u8f6c\u5316\u6210\u94fe\u8868 452. Remove Linked List Elements 113. Remove Duplicates from Sorted List II 165. Merge Two Sorted Lists 451. Swap Nodes in Pairs 450. Reverse Nodes in k-Group \u501f\u927436\u9898\u7684\u601d\u60f3 Insertion Sort List Sort List 372. Delete Node in a Linked List 174. Remove Nth Node From End of List \u65b9\u6cd5\u4e00\uff1a\u4e24\u6b21\u904d\u5386\uff0c\u7b2c\u4e00\u6b21\u904d\u5386\u8ba1\u7b97\u94fe\u8868\u7684\u957f\u5ea6\uff0c\u7b2c\u4e8c\u6b21\u5220\u9664\u6307\u5b9a\u7684\u4f4d\u7f6e \u65b9\u6cd5\u4e8c\uff1a\u5229\u7528\u53cc\u6307\u9488\uff0cp\u548cq\u4e24\u4e2a\u7684\u4f4d\u7f6e\u59cb\u7ec8\u786e\u5b9a\u5728n + 1\u7684\u957f\u5ea6 170. Rotate List 99. Reorder List 223. Palindrome Linked List 228. Middle of Linked List 483. Convert Linked List to Array List 466. Count Linked List Nodes 225. Find Node in Linked List 219. Insert Node in Sorted Linked List 786. Linked List Weighted Sum In Reverse Order 217. Remove Duplicates from Unsorted List 489. Convert Array List to Linked List 822. Reverse Order Storage 166. Nth to Last Node in List 511. Swap Two Nodes in Linked List","title":"3. \u94fe\u8868"},{"location":"linkedlist/#_1","text":"35. Reverse Linked List 36. Reverse Linked List II \u89e3\u6790 \u4e3a\u4e86\u5b9e\u73b0\u5728\u67d0\u4e00\u6bb5[m, n]\u4e0a\u7ffb\u8f6c\u987a\u5e8f\uff0c\u9996\u5148\u8bbe\u7f6e\u865a\u62df\u5934\u7ed3\u70b9\uff0c\u627e\u5230m\u7684\u524d\u4e00\u4e2a\u7ed3\u70b9preNode\uff0c curNode = preNode.next \u83b7\u53d6\u5f53\u524d\u7ed3\u70b9 postNode = curNode.next \u8d1f\u8d23\u79fb\u52a8 \u4f8b\u5982 3->1->4->2->6->7->9->3 \u5728[3,5]\u4e0a\u7ffb\u8f6c\uff0c ListNode dummy = new ListNode ( 0 ); dummy . next = head ; head = dummy ; //\u5728head\u524d\u9762\u63a5\u4e86\u4e00\u4e2a\u865a\u62df\u5934\u7ed3\u70b9 for ( int i = 1 ; i < m ; i ++) { head = head . next ; } ListNode preNode = head ; ListNode curNode = preNode . next ; ListNode postNode = curNode . next ; for ( int i = 0 ; i < n - m ; i ++) { curNode . next = postNode . next ; postNode . next = preNode . next ; preNode . next = postNode ; postNode = curNode . next ; } 112. Remove Duplicates from Sorted List 96. Partition List 1292. Odd Even Linked List \u65b9\u6cd5\u4e00\uff1a \u501f\u9274221\u9898\u7684\u601d\u8def\uff0c\u5229\u7528Queue\u7684FIFO\u539f\u7406\u5c06\u6bcf\u4e2a\u6570\u5b57\u5206\u522b\u5b58\u50a8\u5230\u961f\u5217\u4e2d\uff0c\u518d\u5c06\u961f\u5217\u4e2d\u7684\u6570\u636e\u53d6\u51fa\u8f6c\u5316\u6210\u94fe\u8868 \u65b9\u6cd5\u4e8c\uff1a\u5f00\u59cb\u65f6\u82e5 head,head.next,head.next.next \u90fd\u4e3a\u7a7a\u65f6\u5219\u76f4\u63a5\u8fd4\u56dehead\uff0c\u518d\u540e\u7eed\u5224\u65ad\u4e2dcur,cur.next,cur.next.next\u90fd\u4e3a\u7a7a\u65f6\u5219\u4e0d\u6267\u884c\u4e0b\u53bb 167. Add Two Numbers \u5148\u5206\u522b\u8ba1\u7b97\u51fa\u4e24\u4e2a\u6570\uff0c\u518d\u8ba1\u7b97\u5176\u548c\uff0c\u7136\u540e\u518d\u62c6\u5206\u6210\u94fe\u8868\u7684\u65b9\u6cd5\u4e0d\u53ef\u884c\uff0c\u56e0\u4e3a\u5176\u548c\u4f1a\u8d85\u51faint\u7c7b\u578b\u7684\u8303\u56f4 221. Add Two Numbers II \u5229\u7528Stack\u7684FILO\u539f\u7406\u5c06\u6bcf\u4e2a\u6570\u5b57\u5b58\u50a8\u5230\u4e00\u4e2a\u6808\u4e2d\uff0c\u518d\u5c06\u6808\u4e2d\u7684\u6570\u636e\u53d6\u51fa\u8f6c\u5316\u6210\u94fe\u8868 452. Remove Linked List Elements 113. Remove Duplicates from Sorted List II 165. Merge Two Sorted Lists 451. Swap Nodes in Pairs 450. Reverse Nodes in k-Group \u501f\u927436\u9898\u7684\u601d\u60f3 Insertion Sort List Sort List 372. Delete Node in a Linked List 174. Remove Nth Node From End of List \u65b9\u6cd5\u4e00\uff1a\u4e24\u6b21\u904d\u5386\uff0c\u7b2c\u4e00\u6b21\u904d\u5386\u8ba1\u7b97\u94fe\u8868\u7684\u957f\u5ea6\uff0c\u7b2c\u4e8c\u6b21\u5220\u9664\u6307\u5b9a\u7684\u4f4d\u7f6e \u65b9\u6cd5\u4e8c\uff1a\u5229\u7528\u53cc\u6307\u9488\uff0cp\u548cq\u4e24\u4e2a\u7684\u4f4d\u7f6e\u59cb\u7ec8\u786e\u5b9a\u5728n + 1\u7684\u957f\u5ea6 170. Rotate List 99. Reorder List 223. Palindrome Linked List 228. Middle of Linked List 483. Convert Linked List to Array List 466. Count Linked List Nodes 225. Find Node in Linked List 219. Insert Node in Sorted Linked List 786. Linked List Weighted Sum In Reverse Order 217. Remove Duplicates from Unsorted List 489. Convert Array List to Linked List 822. Reverse Order Storage 166. Nth to Last Node in List 511. Swap Two Nodes in Linked List","title":"\u94fe\u8868"},{"location":"lintcode/","text":"\u6570\u7ec4(\u53cc\u6307\u9488\u548c\u6ed1\u52a8\u7a97\u53e3) \u00b6 other \u00b6 539. Move Zeroes 172. Remove Element 100. Remove Duplicates from Sorted Array 101. Remove Duplicates from Sorted Array II \u5f52\u5e76 \u00b6 64. Merge Sorted Array \u5feb\u901f\u6392\u5e8f \u00b6 5. Kth Largest Element 148. Sort Colors ----\u4e09\u8def\u5feb\u6392 \u53cc\u6307\u9488 \u00b6 608. Two Sum II - Input array is sorted 1282. Reverse Vowels of a String 1283. Reverse String 383. Container With Most Water 415. Valid Palindrome \u6ed1\u52a8\u7a97\u53e3(Sliding Window)( https://blog.csdn.net/yy254117440/article/details/53025142 ) \u00b6 406. Minimum Size Subarray Sum 384. Longest Substring Without Repeating Characters 647. Find All Anagrams in a String \u9996\u5148\u7edf\u8ba1\u5b57\u7b26\u4e32p\u7684\u5b57\u7b26\u4e2a\u6570\uff0c\u7136\u540e\u7528\u4e24\u4e2a\u53d8\u91cfl\u548cr\u8868\u793a\u6ed1\u52a8\u7a97\u53e3\u7684\u5de6\u53f3\u8fb9\u754c\uff0c\u7528\u53d8\u91cfcount\u8868\u793a\u5b57\u7b26\u4e32p\u4e2d\u9700\u8981\u5339\u914d\u7684\u5b57\u7b26\u4e2a\u6570\uff0c\u7136\u540e\u5f00\u59cb\u5faa\u73af\uff0c\u5982\u679c\u53f3\u8fb9\u754c\u7684\u5b57\u7b26\u5df2\u7ecf\u5728\u54c8\u5e0c\u8868\u4e2d\u4e86\uff0c\u8bf4\u660e\u8be5\u5b57\u7b26\u5728p\u4e2d\u6709\u51fa\u73b0\uff0c\u5219count\u81ea\u51cf1\uff0c\u7136\u540e\u54c8\u5e0c\u8868\u4e2d\u8be5\u5b57\u7b26\u4e2a\u6570\u81ea\u51cf1\uff0c\u53f3\u8fb9\u754c\u81ea\u52a01\uff0c\u5982\u679c\u6b64\u65f6count\u51cf\u4e3a0\u4e86\uff0c\u8bf4\u660ep\u4e2d\u7684\u5b57\u7b26\u90fd\u5339\u914d\u4e0a\u4e86\uff0c\u90a3\u4e48\u5c06\u6b64\u65f6\u5de6\u8fb9\u754c\u52a0\u5165\u7ed3\u679cres\u4e2d\u3002 \u5982\u679c\u6b64\u65f6r\u548cl\u7684\u5dee\u4e3ap\u7684\u957f\u5ea6\uff0c\u8bf4\u660e\u6b64\u65f6\u5e94\u8be5\u53bb\u6389\u6700\u5de6\u8fb9\u7684\u4e00\u4e2a\u5b57\u7b26\uff0c\u6211\u4eec\u770b\u5982\u679c\u8be5\u5b57\u7b26\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8e0\uff0c\u8bf4\u660e\u8be5\u5b57\u7b26\u662fp\u4e2d\u7684\u5b57\u7b26\uff0c\u4e3a\u5565\u5462\uff0c\u56e0\u4e3a\u4e0a\u9762\u6211\u4eec\u6709\u8ba9\u6bcf\u4e2a\u5b57\u7b26\u81ea\u51cf1\uff0c\u5982\u679c\u4e0d\u662fp\u4e2d\u7684\u5b57\u7b26\uff0c\u90a3\u4e48\u5728\u54c8\u5e0c\u8868\u4e2d\u4e2a\u6570\u5e94\u8be5\u4e3a0\uff0c\u81ea\u51cf1\u540e\u5c31\u4e3a-1\uff0c\u6240\u4ee5\u8fd9\u6837\u5c31\u77e5\u9053\u8be5\u5b57\u7b26\u662f\u5426\u5c5e\u4e8ep\uff0c\u5982\u679c\u6211\u4eec\u53bb\u6389\u4e86\u5c5e\u4e8ep\u7684\u4e00\u4e2a\u5b57\u7b26\uff0ccount\u81ea\u589e1\uff0c\u53c2\u89c1\u4ee3\u7801\u5982\u4e0b \u5907\u6ce8\uff1ar\u548cl\u7684\u5dee\u4e3ap\u7684\u957f\u5ea6\u65f6\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u521a\u597d\u5339\u914d\u5b8c\u5168\u4e86\u9700\u8981\u7684\u6240\u6709\u5b57\u7b26\uff0c\u53e6\u4e00\u79cd\u662f\u904d\u5386\u4e86p\u7684\u957f\u5ea6\uff0c\u53d1\u73b0\u5b8c\u5168\u4e0d\u7b26\u5408 Java\u5b9e\u73b0 public List < Integer > findAnagrams ( String s , String p ) { List < Integer > list = new ArrayList <>(); char [] ss = s . toCharArray (); char [] pp = p . toCharArray (); int [] map = new int [ 256 ]; for ( int i = 0 ; i < pp . length ; i ++) { map [ pp [ i ]]++; } int l = 0 , r = - 1 , count = pp . length ; while ( r + 1 < ss . length ) { if ( map [ ss [++ r ]]-- >= 1 ) { count --; } if ( count == 0 ) { list . add ( l ); } if ( r - l + 1 == pp . length && map [ ss [ l ++]]++ >= 0 ) { count ++; } } return list ; } 32. Minimum Window Substring Sort Characters By Frequency(leetcode 451)","title":"1. \u53cc\u6307\u9488\u4e0e\u6ed1\u52a8\u7a97\u53e3"},{"location":"lintcode/#_1","text":"","title":"\u6570\u7ec4(\u53cc\u6307\u9488\u548c\u6ed1\u52a8\u7a97\u53e3)"},{"location":"lintcode/#other","text":"539. Move Zeroes 172. Remove Element 100. Remove Duplicates from Sorted Array 101. Remove Duplicates from Sorted Array II","title":"other"},{"location":"lintcode/#_2","text":"64. Merge Sorted Array","title":"\u5f52\u5e76"},{"location":"lintcode/#_3","text":"5. Kth Largest Element 148. Sort Colors ----\u4e09\u8def\u5feb\u6392","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"lintcode/#_4","text":"608. Two Sum II - Input array is sorted 1282. Reverse Vowels of a String 1283. Reverse String 383. Container With Most Water 415. Valid Palindrome","title":"\u53cc\u6307\u9488"},{"location":"lintcode/#sliding-windowhttpsblogcsdnnetyy254117440articledetails53025142","text":"406. Minimum Size Subarray Sum 384. Longest Substring Without Repeating Characters 647. Find All Anagrams in a String \u9996\u5148\u7edf\u8ba1\u5b57\u7b26\u4e32p\u7684\u5b57\u7b26\u4e2a\u6570\uff0c\u7136\u540e\u7528\u4e24\u4e2a\u53d8\u91cfl\u548cr\u8868\u793a\u6ed1\u52a8\u7a97\u53e3\u7684\u5de6\u53f3\u8fb9\u754c\uff0c\u7528\u53d8\u91cfcount\u8868\u793a\u5b57\u7b26\u4e32p\u4e2d\u9700\u8981\u5339\u914d\u7684\u5b57\u7b26\u4e2a\u6570\uff0c\u7136\u540e\u5f00\u59cb\u5faa\u73af\uff0c\u5982\u679c\u53f3\u8fb9\u754c\u7684\u5b57\u7b26\u5df2\u7ecf\u5728\u54c8\u5e0c\u8868\u4e2d\u4e86\uff0c\u8bf4\u660e\u8be5\u5b57\u7b26\u5728p\u4e2d\u6709\u51fa\u73b0\uff0c\u5219count\u81ea\u51cf1\uff0c\u7136\u540e\u54c8\u5e0c\u8868\u4e2d\u8be5\u5b57\u7b26\u4e2a\u6570\u81ea\u51cf1\uff0c\u53f3\u8fb9\u754c\u81ea\u52a01\uff0c\u5982\u679c\u6b64\u65f6count\u51cf\u4e3a0\u4e86\uff0c\u8bf4\u660ep\u4e2d\u7684\u5b57\u7b26\u90fd\u5339\u914d\u4e0a\u4e86\uff0c\u90a3\u4e48\u5c06\u6b64\u65f6\u5de6\u8fb9\u754c\u52a0\u5165\u7ed3\u679cres\u4e2d\u3002 \u5982\u679c\u6b64\u65f6r\u548cl\u7684\u5dee\u4e3ap\u7684\u957f\u5ea6\uff0c\u8bf4\u660e\u6b64\u65f6\u5e94\u8be5\u53bb\u6389\u6700\u5de6\u8fb9\u7684\u4e00\u4e2a\u5b57\u7b26\uff0c\u6211\u4eec\u770b\u5982\u679c\u8be5\u5b57\u7b26\u5728\u54c8\u5e0c\u8868\u4e2d\u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8e0\uff0c\u8bf4\u660e\u8be5\u5b57\u7b26\u662fp\u4e2d\u7684\u5b57\u7b26\uff0c\u4e3a\u5565\u5462\uff0c\u56e0\u4e3a\u4e0a\u9762\u6211\u4eec\u6709\u8ba9\u6bcf\u4e2a\u5b57\u7b26\u81ea\u51cf1\uff0c\u5982\u679c\u4e0d\u662fp\u4e2d\u7684\u5b57\u7b26\uff0c\u90a3\u4e48\u5728\u54c8\u5e0c\u8868\u4e2d\u4e2a\u6570\u5e94\u8be5\u4e3a0\uff0c\u81ea\u51cf1\u540e\u5c31\u4e3a-1\uff0c\u6240\u4ee5\u8fd9\u6837\u5c31\u77e5\u9053\u8be5\u5b57\u7b26\u662f\u5426\u5c5e\u4e8ep\uff0c\u5982\u679c\u6211\u4eec\u53bb\u6389\u4e86\u5c5e\u4e8ep\u7684\u4e00\u4e2a\u5b57\u7b26\uff0ccount\u81ea\u589e1\uff0c\u53c2\u89c1\u4ee3\u7801\u5982\u4e0b \u5907\u6ce8\uff1ar\u548cl\u7684\u5dee\u4e3ap\u7684\u957f\u5ea6\u65f6\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u521a\u597d\u5339\u914d\u5b8c\u5168\u4e86\u9700\u8981\u7684\u6240\u6709\u5b57\u7b26\uff0c\u53e6\u4e00\u79cd\u662f\u904d\u5386\u4e86p\u7684\u957f\u5ea6\uff0c\u53d1\u73b0\u5b8c\u5168\u4e0d\u7b26\u5408 Java\u5b9e\u73b0 public List < Integer > findAnagrams ( String s , String p ) { List < Integer > list = new ArrayList <>(); char [] ss = s . toCharArray (); char [] pp = p . toCharArray (); int [] map = new int [ 256 ]; for ( int i = 0 ; i < pp . length ; i ++) { map [ pp [ i ]]++; } int l = 0 , r = - 1 , count = pp . length ; while ( r + 1 < ss . length ) { if ( map [ ss [++ r ]]-- >= 1 ) { count --; } if ( count == 0 ) { list . add ( l ); } if ( r - l + 1 == pp . length && map [ ss [ l ++]]++ >= 0 ) { count ++; } } return list ; } 32. Minimum Window Substring Sort Characters By Frequency(leetcode 451)","title":"\u6ed1\u52a8\u7a97\u53e3(Sliding Window)(https://blog.csdn.net/yy254117440/article/details/53025142)"},{"location":"other/","text":"java\u76f8\u5173 \u00b6 \u62c6\u7bb1\u4e0e\u88c5\u7bb1 \u00b6 \u88c5\u7bb1 \uff1a\u628a\u4e00\u4e2a\u57fa\u672c\u6570\u636e\u7c7b\u578b\u503c,\u8f6c\u6362\u4e3a\u5bf9\u5e94\u5305\u88c5\u7c7b\u7684\u5bf9\u8c61. \u62c6\u7bb1 \uff1a\u628a\u4e00\u4e2a\u5305\u88c5\u7c7b\u5bf9\u8c61,\u8f6c\u6362\u4e3a\u5bf9\u5e94\u7684\u57fa\u672c\u7c7b\u578b\u7684\u53d8\u91cf(Java5\u5f00\u59cb,\u63d0\u4f9b\u4e86\u81ea\u52a8\u88c5\u62c6\u7bb1). \u6253\u5370\u6570\u7ec4 \u00b6 \u4e00\u7ef4\u6570\u7ec4\uff1aArrays.toString(arr) \u4e8c\u7ef4\u6570\u7ec4\uff1aArrays.deepToString(arr) \u8bbe\u8ba1\u6a21\u5f0f(\u53ef\u7ef4\u62a4\u3001\u53ef\u6269\u5c55\u3001\u53ef\u590d\u7528\u3001\u7075\u6d3b\u6027\u597d) \u00b6 1.\u8bbe\u8ba1\u6a21\u5f0f\u516d\u5927\u539f\u5219 \u00b6 \u5355\u4e00\u804c\u8d23 \u4f9d\u8d56\u5012\u8f6c \u5f00\u653e\u5c01\u95ed\uff1a\u5bf9\u6269\u5c55\u5f00\u653e\uff0c\u5bf9\u4fee\u6539\u5173\u95ed \u91cc\u6c0f\u4ee3\u6362\uff1a\u53ef\u4ee5\u7528\u57fa\u7c7b\u7684\u5730\u65b9\uff0c\u4e5f\u53ef\u4ee5\u7528\u5176\u5b50\u7c7b\u4ee3\u66ff \u63a5\u53e3\u9694\u79bb \u8fea\u7c73\u7279\uff1a\u4e24\u4e2a\u7c7b\u4e4b\u95f4\u4e0d\u76f4\u63a5\u8054\u7cfb\uff0c\u901a\u8fc7\u7b2c\u4e09\u65b9\u8054\u7cfb 2.\u5e38\u89c1\u8bbe\u8ba1\u6a21\u5f0f \u00b6 \u7b80\u5355\u5de5\u5382\u6a21\u5f0f(Simple Factory Pattern) \u7b56\u7565\u6a21\u5f0f(Strategy Pattern) \u88c5\u9970\u6a21\u5f0f(Decorator Pattern) \u5de5\u5382\u65b9\u6cd5(Factory Method Pattern) \u4ee3\u7406\u6a21\u5f0f(Proxy Pattern) \u5355\u4f8b\u8bbe\u8ba1\u6a21\u5f0f(Singleton Pattern) \u997f\u6c49\u5f0f \u79c1\u6709\u5316\u6784\u9020\u5668;\u79c1\u6709\u5316\u7c7b\u53d8\u91cf;\u63d0\u4f9b\u5411\u5916\u66b4\u9732\u8be5\u7c7b\u53d8\u91cf\u7684\u9759\u6001\u65b9\u6cd5 public class Hero { private Hero (){}; private static Hero instance = new Hero (); public static Hero getInstance (){ return instance ; } }","title":"\u4e5d. Java"},{"location":"other/#java","text":"","title":"java\u76f8\u5173"},{"location":"other/#_1","text":"\u88c5\u7bb1 \uff1a\u628a\u4e00\u4e2a\u57fa\u672c\u6570\u636e\u7c7b\u578b\u503c,\u8f6c\u6362\u4e3a\u5bf9\u5e94\u5305\u88c5\u7c7b\u7684\u5bf9\u8c61. \u62c6\u7bb1 \uff1a\u628a\u4e00\u4e2a\u5305\u88c5\u7c7b\u5bf9\u8c61,\u8f6c\u6362\u4e3a\u5bf9\u5e94\u7684\u57fa\u672c\u7c7b\u578b\u7684\u53d8\u91cf(Java5\u5f00\u59cb,\u63d0\u4f9b\u4e86\u81ea\u52a8\u88c5\u62c6\u7bb1).","title":"\u62c6\u7bb1\u4e0e\u88c5\u7bb1"},{"location":"other/#_2","text":"\u4e00\u7ef4\u6570\u7ec4\uff1aArrays.toString(arr) \u4e8c\u7ef4\u6570\u7ec4\uff1aArrays.deepToString(arr)","title":"\u6253\u5370\u6570\u7ec4"},{"location":"other/#_3","text":"","title":"\u8bbe\u8ba1\u6a21\u5f0f(\u53ef\u7ef4\u62a4\u3001\u53ef\u6269\u5c55\u3001\u53ef\u590d\u7528\u3001\u7075\u6d3b\u6027\u597d)"},{"location":"other/#1","text":"\u5355\u4e00\u804c\u8d23 \u4f9d\u8d56\u5012\u8f6c \u5f00\u653e\u5c01\u95ed\uff1a\u5bf9\u6269\u5c55\u5f00\u653e\uff0c\u5bf9\u4fee\u6539\u5173\u95ed \u91cc\u6c0f\u4ee3\u6362\uff1a\u53ef\u4ee5\u7528\u57fa\u7c7b\u7684\u5730\u65b9\uff0c\u4e5f\u53ef\u4ee5\u7528\u5176\u5b50\u7c7b\u4ee3\u66ff \u63a5\u53e3\u9694\u79bb \u8fea\u7c73\u7279\uff1a\u4e24\u4e2a\u7c7b\u4e4b\u95f4\u4e0d\u76f4\u63a5\u8054\u7cfb\uff0c\u901a\u8fc7\u7b2c\u4e09\u65b9\u8054\u7cfb","title":"1.\u8bbe\u8ba1\u6a21\u5f0f\u516d\u5927\u539f\u5219"},{"location":"other/#2","text":"\u7b80\u5355\u5de5\u5382\u6a21\u5f0f(Simple Factory Pattern) \u7b56\u7565\u6a21\u5f0f(Strategy Pattern) \u88c5\u9970\u6a21\u5f0f(Decorator Pattern) \u5de5\u5382\u65b9\u6cd5(Factory Method Pattern) \u4ee3\u7406\u6a21\u5f0f(Proxy Pattern) \u5355\u4f8b\u8bbe\u8ba1\u6a21\u5f0f(Singleton Pattern) \u997f\u6c49\u5f0f \u79c1\u6709\u5316\u6784\u9020\u5668;\u79c1\u6709\u5316\u7c7b\u53d8\u91cf;\u63d0\u4f9b\u5411\u5916\u66b4\u9732\u8be5\u7c7b\u53d8\u91cf\u7684\u9759\u6001\u65b9\u6cd5 public class Hero { private Hero (){}; private static Hero instance = new Hero (); public static Hero getInstance (){ return instance ; } }","title":"2.\u5e38\u89c1\u8bbe\u8ba1\u6a21\u5f0f"},{"location":"quickSort/","text":"QuickSort \u00b6 \u5feb\u901f\u6392\u5e8f\u53c2\u8003 ( http://developer.51cto.com/art/201403/430986.htm ) \u4e00\u822c\u7684\u5feb\u901f\u6392\u5e8f \u00b6 \u5047\u8bbe\u6211\u4eec\u73b0\u5728\u5bf9\u201c6 1 2 7 9 3 4 5 10 8\u201d\u8fd9\u4e2a10\u4e2a\u6570\u8fdb\u884c\u6392\u5e8f\u3002\u9996\u5148\u4ee5\u7b2c\u4e00\u4e2a\u65706\u4f5c\u4e3a\u57fa\u51c6\u6570\u5427\u3002\u63a5\u4e0b\u6765\uff0c\u9700\u8981\u5c06\u8fd9\u4e2a\u5e8f\u5217\u4e2d\u6240\u6709\u6bd4\u57fa\u51c6\u6570\u5927\u7684\u6570\u653e\u57286\u7684\u53f3\u8fb9\uff0c\u6bd4\u57fa\u51c6\u6570\u5c0f\u7684\u6570\u653e\u57286\u7684\u5de6\u8fb9\uff0c\u7c7b\u4f3c\u4e0b\u9762\u8fd9\u79cd\u6392\u5217\uff1a 3 1 2 5 4 6 9 7 10 8 \u5b9e\u73b0\u4ee3\u7801 public class QuickSort { public static void sort2 ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } if ( i < j ) { swap ( arr , i , j ); } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } if ( i < j ) { swap ( arr , i , j ); } } sort2 ( arr , lo , i - 1 ); sort2 ( arr , i + 1 , hi ); } public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Object [] arr , int i , int j ) { Object t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } } \u968f\u673a\u5316\u5feb\u901f\u6392\u5e8f \u00b6 \u5982\u679c\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u662f\u8fd1\u4e4e\u6709\u5e8f\u7684\uff0c\u8fd9\u65f6\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c06\u9000\u5316\u6210O(n 2 )\uff0c\u4e3a\u4e86\u7ef4\u6301O(nlogn)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u9700\u8981\u6539\u53d8\u9009\u62e9\u7684\u57fa\u51c6(sentinel)\uff0c\u53d6\u5176\u968f\u673a\u4e00\u4e2a\u6570\u4e3a\u57fa\u51c6\u3002 \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort2 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } } \u4e09\u8def\u5feb\u901f\u6392\u5e8f \u00b6 \u7136\u800c\u5f53\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u4e2d\u5b58\u5728\u5927\u91cf\u91cd\u590d\u5143\u7d20\u65f6\uff0c\u5219\u9700\u8981\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 \u52a8\u753b\u6f14\u793a \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort3 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int lt = lo ; int gt = hi + 1 ; int i = lo + 1 ; while ( i < gt ) { if ( arr [ i ]. compareTo ( sentinel ) < 0 ) { swap ( arr , i , lt + 1 ); i ++; lt ++; } else if ( arr [ i ]. compareTo ( sentinel ) > 0 ) { swap ( arr , i , gt - 1 ); gt --; } else { i ++; } } swap ( arr , lo , lt ); sort ( arr , lo , lt - 1 ); sort ( arr , gt , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } public static void main ( String [] args ) { int n = 1000000 ; Comparable [] arr = new Comparable [ n ]; for ( int i = 0 ; i < n ; i ++) { arr [ i ] = i / 100000 ; } long startTime = System . nanoTime (); sort ( arr , 0 , arr . length - 1 ); long endTime = System . nanoTime (); System . out . println (( endTime - startTime ) / 1000000000.0 + \" s\" ); } } MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u4e94. QuickSort"},{"location":"quickSort/#quicksort","text":"\u5feb\u901f\u6392\u5e8f\u53c2\u8003 ( http://developer.51cto.com/art/201403/430986.htm )","title":"QuickSort"},{"location":"quickSort/#_1","text":"\u5047\u8bbe\u6211\u4eec\u73b0\u5728\u5bf9\u201c6 1 2 7 9 3 4 5 10 8\u201d\u8fd9\u4e2a10\u4e2a\u6570\u8fdb\u884c\u6392\u5e8f\u3002\u9996\u5148\u4ee5\u7b2c\u4e00\u4e2a\u65706\u4f5c\u4e3a\u57fa\u51c6\u6570\u5427\u3002\u63a5\u4e0b\u6765\uff0c\u9700\u8981\u5c06\u8fd9\u4e2a\u5e8f\u5217\u4e2d\u6240\u6709\u6bd4\u57fa\u51c6\u6570\u5927\u7684\u6570\u653e\u57286\u7684\u53f3\u8fb9\uff0c\u6bd4\u57fa\u51c6\u6570\u5c0f\u7684\u6570\u653e\u57286\u7684\u5de6\u8fb9\uff0c\u7c7b\u4f3c\u4e0b\u9762\u8fd9\u79cd\u6392\u5217\uff1a 3 1 2 5 4 6 9 7 10 8 \u5b9e\u73b0\u4ee3\u7801 public class QuickSort { public static void sort2 ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } if ( i < j ) { swap ( arr , i , j ); } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } if ( i < j ) { swap ( arr , i , j ); } } sort2 ( arr , lo , i - 1 ); sort2 ( arr , i + 1 , hi ); } public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Object [] arr , int i , int j ) { Object t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } }","title":"\u4e00\u822c\u7684\u5feb\u901f\u6392\u5e8f"},{"location":"quickSort/#_2","text":"\u5982\u679c\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u662f\u8fd1\u4e4e\u6709\u5e8f\u7684\uff0c\u8fd9\u65f6\u5feb\u901f\u6392\u5e8f\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c06\u9000\u5316\u6210O(n 2 )\uff0c\u4e3a\u4e86\u7ef4\u6301O(nlogn)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u9700\u8981\u6539\u53d8\u9009\u62e9\u7684\u57fa\u51c6(sentinel)\uff0c\u53d6\u5176\u968f\u673a\u4e00\u4e2a\u6570\u4e3a\u57fa\u51c6\u3002 \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort2 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int i = lo ; int j = hi ; while ( i != j ) { while ( arr [ j ]. compareTo ( sentinel ) >= 0 && i < j ) { j --; } while ( arr [ i ]. compareTo ( sentinel ) <= 0 && i < j ) { i ++; } swap ( arr , i , j ); } if ( i > lo ) { arr [ lo ] = arr [ i ]; arr [ i ] = sentinel ; } sort ( arr , lo , i - 1 ); sort ( arr , i + 1 , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } }","title":"\u968f\u673a\u5316\u5feb\u901f\u6392\u5e8f"},{"location":"quickSort/#_3","text":"\u7136\u800c\u5f53\u9700\u8981\u6392\u5e8f\u7684\u5bf9\u8c61\u4e2d\u5b58\u5728\u5927\u91cf\u91cd\u590d\u5143\u7d20\u65f6\uff0c\u5219\u9700\u8981\u8fdb\u4e00\u6b65\u4f18\u5316\u3002 \u52a8\u753b\u6f14\u793a \u4ee3\u7801\u5b9e\u73b0 import java.util.Arrays ; public class QuickSort3 { public static void sort ( Comparable [] arr , int lo , int hi ) { if ( lo > hi ) { return ; } swap ( arr , lo , ( int ) ( Math . random () * ( hi - lo + 1 )) + lo ); Comparable sentinel = arr [ lo ]; int lt = lo ; int gt = hi + 1 ; int i = lo + 1 ; while ( i < gt ) { if ( arr [ i ]. compareTo ( sentinel ) < 0 ) { swap ( arr , i , lt + 1 ); i ++; lt ++; } else if ( arr [ i ]. compareTo ( sentinel ) > 0 ) { swap ( arr , i , gt - 1 ); gt --; } else { i ++; } } swap ( arr , lo , lt ); sort ( arr , lo , lt - 1 ); sort ( arr , gt , hi ); } private static void swap ( Comparable [] arr , int i , int j ) { Comparable t = arr [ i ]; arr [ i ] = arr [ j ]; arr [ j ] = t ; } public static void main ( String [] args ) { int n = 1000000 ; Comparable [] arr = new Comparable [ n ]; for ( int i = 0 ; i < n ; i ++) { arr [ i ] = i / 100000 ; } long startTime = System . nanoTime (); sort ( arr , 0 , arr . length - 1 ); long endTime = System . nanoTime (); System . out . println (( endTime - startTime ) / 1000000000.0 + \" s\" ); } } MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","title":"\u4e09\u8def\u5feb\u901f\u6392\u5e8f"},{"location":"review/","text":"Knowledge review \u00b6 DataStructure \u00b6 linear \u00b6 Array(\u53ef\u6269\u5bb9\u7684) LinkedList(\u865a\u62df\u5934\u7ed3\u70b9) Stack Implements By Array Or LinkedList Queue Implements By Array Or LinkedList LoopQueue PriorityQueue(MaxHeap) MaxHeap tree \u00b6 binary search tree avltree(\u5de6\u65cb\u548c\u53f3\u65cb) rbtree(\u7ea2\u9ed1\u6811) trie(\u5b57\u6bcd\u6811) segment tree(\u7ebf\u6bb5\u6811) unionfind(\u5e76\u67e5\u96c6) map and set \u00b6 LinkedListMap BSTMap LinkedListSet BStSet hashcode \u00b6 Algorithm \u00b6 sort \u00b6 BubbleSort InsertionSort SelectSort MergeSort HeapSort QuickSort(include \u4e09\u8def\u5feb\u6392) dynamic programming \u00b6 backpack(\u80cc\u5305) sequence(\u5e8f\u5217) coordinate(\u5750\u6807) division(\u5212\u5206) interval(\u533a\u95f4) winorlose(\u535a\u5f08) Java \u00b6 Reflection(\u53cd\u5c04) Introspector(\u5185\u7701) Design Pattern(23) \u00b6 MVC(Model View Controller) \u00b6 Javabean + JSP + Servlet Struts2 + Spring + Hibernate(SSH) SpringMVC + Spring + MyBatis(SSM)","title":"\u516b. \u56de\u987e"},{"location":"review/#knowledge-review","text":"","title":"Knowledge review"},{"location":"review/#datastructure","text":"","title":"DataStructure"},{"location":"review/#linear","text":"Array(\u53ef\u6269\u5bb9\u7684) LinkedList(\u865a\u62df\u5934\u7ed3\u70b9) Stack Implements By Array Or LinkedList Queue Implements By Array Or LinkedList LoopQueue PriorityQueue(MaxHeap) MaxHeap","title":"linear"},{"location":"review/#tree","text":"binary search tree avltree(\u5de6\u65cb\u548c\u53f3\u65cb) rbtree(\u7ea2\u9ed1\u6811) trie(\u5b57\u6bcd\u6811) segment tree(\u7ebf\u6bb5\u6811) unionfind(\u5e76\u67e5\u96c6)","title":"tree"},{"location":"review/#map-and-set","text":"LinkedListMap BSTMap LinkedListSet BStSet","title":"map and set"},{"location":"review/#hashcode","text":"","title":"hashcode"},{"location":"review/#algorithm","text":"","title":"Algorithm"},{"location":"review/#sort","text":"BubbleSort InsertionSort SelectSort MergeSort HeapSort QuickSort(include \u4e09\u8def\u5feb\u6392)","title":"sort"},{"location":"review/#dynamic-programming","text":"backpack(\u80cc\u5305) sequence(\u5e8f\u5217) coordinate(\u5750\u6807) division(\u5212\u5206) interval(\u533a\u95f4) winorlose(\u535a\u5f08)","title":"dynamic programming"},{"location":"review/#java","text":"Reflection(\u53cd\u5c04) Introspector(\u5185\u7701)","title":"Java"},{"location":"review/#design-pattern23","text":"","title":"Design Pattern(23)"},{"location":"review/#mvcmodel-view-controller","text":"Javabean + JSP + Servlet Struts2 + Spring + Hibernate(SSH) SpringMVC + Spring + MyBatis(SSM)","title":"MVC(Model View Controller)"},{"location":"stack/","text":"Stack \u00b6 423. Valid Parentheses","title":"4. \u6808\u4e0e\u961f\u5217"},{"location":"stack/#stack","text":"423. Valid Parentheses","title":"Stack"},{"location":"\u4e00\u4eba\u4e4b\u4e0b/","text":"\u4e00\u4eba\u4e4b\u4e0b001 \u00b6","title":"\u4e00\u4eba\u4e4b\u4e0b"},{"location":"\u4e00\u4eba\u4e4b\u4e0b/#001","text":"","title":"\u4e00\u4eba\u4e4b\u4e0b001"},{"location":"BinaryTree/AVLTree/","text":"AVL\u6811 \u00b6 1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb \u00b6 1.1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u89c4\u5219 \u00b6 1.2 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u5b9e\u4f8b \u00b6 \u5907\u6ce8\uff1a\u5728\u5de6\u65cb\u548c\u53f3\u65cb\u65f6\u9700\u8981\u91cd\u65b0\u8ba1\u7b97height\u503c \u5de6\u65cb\u4e0e\u53f3\u65cb // \u53f3\u65cb // y x // / \\ / \\ // x T4 \u5411\u53f3\u65cb\u8f6c(y) z y // / \\ - - - - - - -> / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate ( Node y ) { Node x = y . left ; Node T3 = x . right ; x . right = y ; y . left = T3 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } // \u5de6\u65cb // y x // / \\ / \\ // T1 x \u5411\u5de6\u65cb\u8f6c(y) y z // / \\ - - - - - - -> / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate ( Node y ) { Node x = y . right ; Node T2 = x . left ; x . left = y ; y . right = T2 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } 2 AVL\u6811\u7684\u6574\u4f53\u4ee3\u7801 \u00b6 Java\u7248 import java.util.Queue ; import java.util.List ; import java.util.ArrayList ; import java.util.LinkedList ; public class AVLTree < K extends Comparable < K >, V > { private class Node { public K key ; public V value ; public Node left ; public Node right ; public int height ; public Node ( K key , V value ) { this . key = key ; this . value = value ; this . left = null ; this . right = null ; this . height = 1 ; } } private Node root ; private int size ; public AVLTree () { root = null ; size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } // \u8ba1\u7b97\u9ad8\u5ea6 public int getHeight ( Node node ) { if ( node == null ) { return 0 ; } return node . height ; } // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 private int getBalanceFactor ( Node node ) { if ( node == null ) { return 0 ; } return getHeight ( node . left ) - getHeight ( node . right ); } // \u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u641c\u7d22\u6811 public boolean isBST () { List < K > keys = new ArrayList <>(); inOrder ( root , keys ); for ( int i = 1 ; i < keys . size (); i ++) { if ( keys . get ( i ). compareTo ( keys . get ( i - 1 )) < 0 ) { return false ; } } return true ; } private void inOrder ( Node node , List < K > keys ) { if ( node == null ) { return ; } inOrder ( node . left , keys ); keys . add ( node . key ); inOrder ( node . right , keys ); } // \u5224\u65ad\u662f\u5426\u4e3a\u5e73\u8861\u4e8c\u53c9\u6811 public boolean isBalanced () { return isBalanced ( root ); } private boolean isBalanced ( Node node ) { if ( node == null ) { return true ; } int balanceFactor = getBalanceFactor ( node ); if ( Math . abs ( balanceFactor ) > 1 ) { return false ; } return isBalanced ( node . left ) && isBalanced ( node . right ); } private Node getNode ( Node node , K key ) { if ( node == null ) { return null ; } if ( key . compareTo ( node . key ) < 0 ) { return getNode ( node . left , key ); } else if ( key . compareTo ( node . key ) > 0 ) { return getNode ( node . right , key ); } else { return node ; } } public boolean contains ( K key ) { return getNode ( root , key ) != null ; } public void preOrder () { preOrder ( root ); } private void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . key ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder () { inOrder ( root ); } private void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . key ); inOrder ( node . right ); } public void postOrder () { postOrder ( root ); } private void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . key ); } public void levelOrder () { Queue < Node > q = new LinkedList <>(); q . add ( root ); while (! q . isEmpty ()) { Node cur = q . remove (); System . out . println ( cur . key ); if ( cur . left != null ) { q . add ( cur . left ); } if ( cur . right != null ) { q . add ( cur . right ); } } } public V get ( K key ) { Node node = getNode ( root , key ); return node == null ? null : node . value ; } public void set ( K key , V newValue ) { Node node = getNode ( root , key ); if ( node == null ) { throw new IllegalArgumentException ( key + \"doesn't exist!\" ); } node . value = newValue ; } // \u53f3\u65cb // y x // / \\ / \\ // x T4 \u5411\u53f3\u65cb\u8f6c(y) z y // / \\ - - - - - - -> / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate ( Node y ) { Node x = y . left ; Node T3 = x . right ; x . right = y ; y . left = T3 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } // \u5de6\u65cb // y x // / \\ / \\ // T1 x \u5411\u5de6\u65cb\u8f6c(y) y z // / \\ - - - - - - -> / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate ( Node y ) { Node x = y . right ; Node T2 = x . left ; x . left = y ; y . right = T2 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } public void add ( K key , V value ) { root = add ( root , key , value ); } private Node add ( Node node , K key , V value ) { if ( node == null ) { size ++; return new Node ( key , value ); } if ( key . compareTo ( node . key ) < 0 ) { node . left = add ( node . left , key , value ); } if ( key . compareTo ( node . key ) > 0 ) { node . right = add ( node . right , key , value ); } else { node . value = value ; } // \u8ba1\u7b97\u9ad8\u5ea6 node . height = 1 + Math . max ( getHeight ( node . left ), getHeight ( node . right )); // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 int balanceFactor = getBalanceFactor ( node ); // LL if ( balanceFactor > 1 && getBalanceFactor ( node . left ) >= 0 ) { return rightRotate ( node ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) <= 0 ) { return leftRotate ( node ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( node . left ) < 0 ) { node . left = leftRotate ( node . left ); return rightRotate ( node ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) > 0 ) { node . right = rightRotate ( node . right ); return leftRotate ( node ); } return node ; } public K findMin () { if ( size == 0 ) { throw new IllegalArgumentException ( \"Can not find something from a blank tree.\" ); } return findMin ( root ). key ; } private Node findMin ( Node node ) { if ( node . left == null ) { return node ; } return findMin ( node . left ); } public K removeMin () { K ret = findMin (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public void remove ( K key ) { root = remove ( root , key ); } private Node remove ( Node node , K key ) { if ( node == null ) { return null ; } Node retNode ; if ( key . compareTo ( node . key ) < 0 ) { node . left = remove ( node . left , key ); retNode = node ; } else if ( key . compareTo ( node . key ) > 0 ) { node . right = remove ( node . right , key ); retNode = node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; retNode = rightNode ; } else if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; retNode = leftNode ; } else { Node successor = findMin ( node . right ); // successor.right = removeMin(node.right); successor . right = remove ( node . right , successor . key ); successor . left = node . left ; node . left = node . right = null ; retNode = successor ; } } if ( retNode == null ) { return null ; } retNode . height = 1 + Math . max ( getHeight ( retNode . left ), getHeight ( retNode . right )); int balanceFactor = getBalanceFactor ( retNode ); // LL if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) >= 0 ) { return rightRotate ( retNode ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) <= 0 ) { return leftRotate ( retNode ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) < 0 ) { retNode . left = leftRotate ( retNode . left ); return rightRotate ( retNode ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) > 0 ) { retNode . right = rightRotate ( retNode . right ); return leftRotate ( retNode ); } return retNode ; } }","title":"4. avlTree"},{"location":"BinaryTree/AVLTree/#avl","text":"","title":"AVL\u6811"},{"location":"BinaryTree/AVLTree/#1-avl","text":"","title":"1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb"},{"location":"BinaryTree/AVLTree/#11-avl","text":"","title":"1.1 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u89c4\u5219"},{"location":"BinaryTree/AVLTree/#12-avl","text":"\u5907\u6ce8\uff1a\u5728\u5de6\u65cb\u548c\u53f3\u65cb\u65f6\u9700\u8981\u91cd\u65b0\u8ba1\u7b97height\u503c \u5de6\u65cb\u4e0e\u53f3\u65cb // \u53f3\u65cb // y x // / \\ / \\ // x T4 \u5411\u53f3\u65cb\u8f6c(y) z y // / \\ - - - - - - -> / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate ( Node y ) { Node x = y . left ; Node T3 = x . right ; x . right = y ; y . left = T3 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } // \u5de6\u65cb // y x // / \\ / \\ // T1 x \u5411\u5de6\u65cb\u8f6c(y) y z // / \\ - - - - - - -> / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate ( Node y ) { Node x = y . right ; Node T2 = x . left ; x . left = y ; y . right = T2 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; }","title":"1.2 AVL\u6811\u7684\u5de6\u65cb\u4e0e\u53f3\u65cb\u7684\u5b9e\u4f8b"},{"location":"BinaryTree/AVLTree/#2-avl","text":"Java\u7248 import java.util.Queue ; import java.util.List ; import java.util.ArrayList ; import java.util.LinkedList ; public class AVLTree < K extends Comparable < K >, V > { private class Node { public K key ; public V value ; public Node left ; public Node right ; public int height ; public Node ( K key , V value ) { this . key = key ; this . value = value ; this . left = null ; this . right = null ; this . height = 1 ; } } private Node root ; private int size ; public AVLTree () { root = null ; size = 0 ; } public int getSize () { return size ; } public boolean isEmpty () { return size == 0 ; } // \u8ba1\u7b97\u9ad8\u5ea6 public int getHeight ( Node node ) { if ( node == null ) { return 0 ; } return node . height ; } // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 private int getBalanceFactor ( Node node ) { if ( node == null ) { return 0 ; } return getHeight ( node . left ) - getHeight ( node . right ); } // \u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u641c\u7d22\u6811 public boolean isBST () { List < K > keys = new ArrayList <>(); inOrder ( root , keys ); for ( int i = 1 ; i < keys . size (); i ++) { if ( keys . get ( i ). compareTo ( keys . get ( i - 1 )) < 0 ) { return false ; } } return true ; } private void inOrder ( Node node , List < K > keys ) { if ( node == null ) { return ; } inOrder ( node . left , keys ); keys . add ( node . key ); inOrder ( node . right , keys ); } // \u5224\u65ad\u662f\u5426\u4e3a\u5e73\u8861\u4e8c\u53c9\u6811 public boolean isBalanced () { return isBalanced ( root ); } private boolean isBalanced ( Node node ) { if ( node == null ) { return true ; } int balanceFactor = getBalanceFactor ( node ); if ( Math . abs ( balanceFactor ) > 1 ) { return false ; } return isBalanced ( node . left ) && isBalanced ( node . right ); } private Node getNode ( Node node , K key ) { if ( node == null ) { return null ; } if ( key . compareTo ( node . key ) < 0 ) { return getNode ( node . left , key ); } else if ( key . compareTo ( node . key ) > 0 ) { return getNode ( node . right , key ); } else { return node ; } } public boolean contains ( K key ) { return getNode ( root , key ) != null ; } public void preOrder () { preOrder ( root ); } private void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . key ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder () { inOrder ( root ); } private void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . key ); inOrder ( node . right ); } public void postOrder () { postOrder ( root ); } private void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . key ); } public void levelOrder () { Queue < Node > q = new LinkedList <>(); q . add ( root ); while (! q . isEmpty ()) { Node cur = q . remove (); System . out . println ( cur . key ); if ( cur . left != null ) { q . add ( cur . left ); } if ( cur . right != null ) { q . add ( cur . right ); } } } public V get ( K key ) { Node node = getNode ( root , key ); return node == null ? null : node . value ; } public void set ( K key , V newValue ) { Node node = getNode ( root , key ); if ( node == null ) { throw new IllegalArgumentException ( key + \"doesn't exist!\" ); } node . value = newValue ; } // \u53f3\u65cb // y x // / \\ / \\ // x T4 \u5411\u53f3\u65cb\u8f6c(y) z y // / \\ - - - - - - -> / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 private Node rightRotate ( Node y ) { Node x = y . left ; Node T3 = x . right ; x . right = y ; y . left = T3 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } // \u5de6\u65cb // y x // / \\ / \\ // T1 x \u5411\u5de6\u65cb\u8f6c(y) y z // / \\ - - - - - - -> / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T3 T4 private Node leftRotate ( Node y ) { Node x = y . right ; Node T2 = x . left ; x . left = y ; y . right = T2 ; y . height = 1 + Math . max ( getHeight ( y . left ), getHeight ( y . right )); x . height = 1 + Math . max ( getHeight ( x . left ), getHeight ( x . right )); return x ; } public void add ( K key , V value ) { root = add ( root , key , value ); } private Node add ( Node node , K key , V value ) { if ( node == null ) { size ++; return new Node ( key , value ); } if ( key . compareTo ( node . key ) < 0 ) { node . left = add ( node . left , key , value ); } if ( key . compareTo ( node . key ) > 0 ) { node . right = add ( node . right , key , value ); } else { node . value = value ; } // \u8ba1\u7b97\u9ad8\u5ea6 node . height = 1 + Math . max ( getHeight ( node . left ), getHeight ( node . right )); // \u8ba1\u7b97\u5e73\u8861\u56e0\u5b50 int balanceFactor = getBalanceFactor ( node ); // LL if ( balanceFactor > 1 && getBalanceFactor ( node . left ) >= 0 ) { return rightRotate ( node ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) <= 0 ) { return leftRotate ( node ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( node . left ) < 0 ) { node . left = leftRotate ( node . left ); return rightRotate ( node ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( node . right ) > 0 ) { node . right = rightRotate ( node . right ); return leftRotate ( node ); } return node ; } public K findMin () { if ( size == 0 ) { throw new IllegalArgumentException ( \"Can not find something from a blank tree.\" ); } return findMin ( root ). key ; } private Node findMin ( Node node ) { if ( node . left == null ) { return node ; } return findMin ( node . left ); } public K removeMin () { K ret = findMin (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public void remove ( K key ) { root = remove ( root , key ); } private Node remove ( Node node , K key ) { if ( node == null ) { return null ; } Node retNode ; if ( key . compareTo ( node . key ) < 0 ) { node . left = remove ( node . left , key ); retNode = node ; } else if ( key . compareTo ( node . key ) > 0 ) { node . right = remove ( node . right , key ); retNode = node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; retNode = rightNode ; } else if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; retNode = leftNode ; } else { Node successor = findMin ( node . right ); // successor.right = removeMin(node.right); successor . right = remove ( node . right , successor . key ); successor . left = node . left ; node . left = node . right = null ; retNode = successor ; } } if ( retNode == null ) { return null ; } retNode . height = 1 + Math . max ( getHeight ( retNode . left ), getHeight ( retNode . right )); int balanceFactor = getBalanceFactor ( retNode ); // LL if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) >= 0 ) { return rightRotate ( retNode ); } // RR if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) <= 0 ) { return leftRotate ( retNode ); } // LR if ( balanceFactor > 1 && getBalanceFactor ( retNode . left ) < 0 ) { retNode . left = leftRotate ( retNode . left ); return rightRotate ( retNode ); } // RL if ( balanceFactor < - 1 && getBalanceFactor ( retNode . right ) > 0 ) { retNode . right = rightRotate ( retNode . right ); return leftRotate ( retNode ); } return retNode ; } }","title":"2 AVL\u6811\u7684\u6574\u4f53\u4ee3\u7801"},{"location":"BinaryTree/binarySearchTree/","text":"Binary Search Tree \u00b6 1.\u4e8c\u5206\u641c\u7d22\u6811(Binary Search Tree, BST) \u00b6 1.1 \u4e8c\u5206\u641c\u7d22\u6811\u7684\u6574\u4f53\u4ee3\u7801 \u00b6 Java\u7248 import java.util.LinkedList ; import java.util.Queue ; public class BST < E extends Comparable < E >> { private class Node { public E e ; public Node left ; public Node right ; public Node ( E e ) { this . e = e ; this . left = null ; this . right = null ; } } private Node root ; private int size ; public BST () { root = null ; size = 0 ; } public int size () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( E e ) { root = add ( root , e ); } // return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; } public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } } public E minimum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return minimum ( root ). e ; } private Node minimum ( Node node ) { if ( node . left == null ) { return node ; } return minimum ( node . left ); } public E removeMin () { E ret = minimum (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public E maximum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return maximum ( root ). e ; } private Node maximum ( Node node ) { if ( node . right == null ) { return node ; } return maximum ( node . right ); } public E removeMax () { E ret = maximum (); root = removeMax ( root ); return ret ; } private Node removeMax ( Node node ) { if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } node . right = removeMax ( node . right ); return node ; } public void remove ( E e ) { root = remove ( root , e ); } private Node remove ( Node node , E e ) { if ( node == null ) { return null ; } if ( e . compareTo ( node . e ) < 0 ) { node . left = remove ( node . left , e ); return node ; } else if ( e . compareTo ( node . e ) > 0 ) { node . right = remove ( node . right , e ); return node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } Node successor = minimum ( node . right ); successor . right = removeMin ( node . right ); successor . left = node . left ; node . left = node . right = null ; return successor ; } } } 1.2 add method \u00b6 1.2.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09 \u00b6 Java\u7248 public void add ( E e ) { Node node = new Node ( e ); if ( root == null ) { root = node ; size ++; } else { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) < 0 ) { if ( temp . left == null ) { temp . left = node ; size ++; return ; } else { temp = temp . left ; } } else { if ( temp . right == null ) { temp . right = node ; szie ++; return ; } else { temp = temp . right ; } } } } } 1.2.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09 \u00b6 Java\u7248 public void add ( E e ) { if ( root == null ) { root = new Node ( e ); size ++; } else { add ( root , e ); } } private void add ( Node node , E e ) { if ( e . equals ( node . e )) { return ; } else if ( e . compareTo ( node . e ) < 0 && node . left == null ) { node . left = new Node ( e ); size ++; return ; } else if ( e . compareTo ( node . e ) > 0 && node . right == null ) { node . right = new Node ( e ); size ++; return ; } if ( e . compareTo ( node . e ) < 0 ) { add ( node . left , e ); } else { add ( node . right , e ); } } 1.2.3 \u9012\u5f52\u5b9e\u73b0\uff08optimize and refactor recursion method\uff09 \u00b6 Java\u7248 // recurse method optimization and refactor public void add ( E e ) { root = add ( root , e ); } //return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; } 1.3 search method \u00b6 1.3.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09 \u00b6 Java\u7248 public boolean contains ( E e ) { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) == 0 ) { return true ; } else if ( e . compareTo ( temp . e ) < 0 ) { temp = temp . left ; } else { temp = temp . right ; } } return false ; } 1.3.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09 \u00b6 Java\u7248 public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } } 1.4 traversal method \u00b6 1.4.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09 \u00b6 Stack\u5b9e\u73b0preOrder public void preOrder ( Node node ) { if ( node == null ) { return ; } Stack < Node > stack = new Stack <>(); stack . push ( node ); while (! stack . isEmpty ()) { Node cur = stack . pop (); System . out . println ( cur . e ); if ( cur . right != null ) { stack . push ( cur . right ); } if ( cur . left != null ) { stack . push ( cur . left ); } } } Queue\u5b9e\u73b0levelOrder public void levelOrder () { if ( root == null ) { return ; } Queue < Node > q = new LinkedList <>(); q . add ( root ); while (! q . isEmpty ()) { Node cur = q . remove (); System . out . println ( cur . e ); if ( cur . left != null ) { q . add ( cur . left ); } if ( cur . right != null ) { q . add ( cur . right ); } } } 1.4.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09 \u00b6 Java\u7248 public void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . e ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . e ); inOrder ( node . right ); } public void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . e ); } 1.5 \u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u641c\u7d22\u6811\u6216\u8005\u662f\u5426\u4e3a\u5e73\u8861\u4e8c\u53c9\u6811 \u00b6 Java\u7248 public int getHeight ( Node node ) { if ( node == null ) { return 0 ; } int leftHeight = getHeight ( node . left ); int rightHeight = getHeight ( node . right ); return 1 + Math . max ( leftHeight , rightHeight ); } public ArrayList < E > inOrder ( Node node , ArrayList < E > list ) { if ( node == null ) { return null ; } inOrder ( node . left , list ); list . add ( node . e ); inOrder ( node . right , list ); return list ; } public boolean isBST () { ArrayList < E > list = new ArrayList <>(); list = inOrder ( root , list ); for ( int i = 1 ; i < list . size (); i ++) { if ( list . get ( i ). compareTo ( list . get ( i - 1 )) < 0 ) { return false ; } } return true ; } public boolean isBalanced () { return isBalanced ( root ); } private boolean isBalanced ( Node node ) { if ( node == null ) { return true ; } int balanceFactor = getBalanceFactor ( node ); if ( Math . abs ( balanceFactor ) > 1 ) { return false ; } return isBalanced ( node . left ) && isBalanced ( node . right ); } private int getBalanceFactor ( Node node ) { if ( node == null ) { return 0 ; } return getHeight ( node . left ) - getHeight ( node . right ); } 1.6 \u4e8c\u5206\u641c\u7d22\u6811\u7684\u7f3a\u70b9 \u00b6 \u5f53\u63d2\u5165\u6709\u5e8f\u8868\u65f6\uff0c\u4f1a\u9000\u5316\u6210\u4e00\u4e2a\u94fe\u8868","title":"3. bst"},{"location":"BinaryTree/binarySearchTree/#binary-search-tree","text":"","title":"Binary Search Tree"},{"location":"BinaryTree/binarySearchTree/#1binary-search-tree-bst","text":"","title":"1.\u4e8c\u5206\u641c\u7d22\u6811(Binary Search Tree, BST)"},{"location":"BinaryTree/binarySearchTree/#11","text":"Java\u7248 import java.util.LinkedList ; import java.util.Queue ; public class BST < E extends Comparable < E >> { private class Node { public E e ; public Node left ; public Node right ; public Node ( E e ) { this . e = e ; this . left = null ; this . right = null ; } } private Node root ; private int size ; public BST () { root = null ; size = 0 ; } public int size () { return size ; } public boolean isEmpty () { return size == 0 ; } public void add ( E e ) { root = add ( root , e ); } // return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; } public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } } public E minimum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return minimum ( root ). e ; } private Node minimum ( Node node ) { if ( node . left == null ) { return node ; } return minimum ( node . left ); } public E removeMin () { E ret = minimum (); root = removeMin ( root ); return ret ; } private Node removeMin ( Node node ) { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } node . left = removeMin ( node . left ); return node ; } public E maximum () { if ( size == 0 ) { throw new IllegalArgumentException ( \"BST is empty!\" ); } return maximum ( root ). e ; } private Node maximum ( Node node ) { if ( node . right == null ) { return node ; } return maximum ( node . right ); } public E removeMax () { E ret = maximum (); root = removeMax ( root ); return ret ; } private Node removeMax ( Node node ) { if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } node . right = removeMax ( node . right ); return node ; } public void remove ( E e ) { root = remove ( root , e ); } private Node remove ( Node node , E e ) { if ( node == null ) { return null ; } if ( e . compareTo ( node . e ) < 0 ) { node . left = remove ( node . left , e ); return node ; } else if ( e . compareTo ( node . e ) > 0 ) { node . right = remove ( node . right , e ); return node ; } else { if ( node . left == null ) { Node rightNode = node . right ; node . right = null ; size --; return rightNode ; } if ( node . right == null ) { Node leftNode = node . left ; node . left = null ; size --; return leftNode ; } Node successor = minimum ( node . right ); successor . right = removeMin ( node . right ); successor . left = node . left ; node . left = node . right = null ; return successor ; } } }","title":"1.1 \u4e8c\u5206\u641c\u7d22\u6811\u7684\u6574\u4f53\u4ee3\u7801"},{"location":"BinaryTree/binarySearchTree/#12-add-method","text":"","title":"1.2 add method"},{"location":"BinaryTree/binarySearchTree/#121-not-recursion","text":"Java\u7248 public void add ( E e ) { Node node = new Node ( e ); if ( root == null ) { root = node ; size ++; } else { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) < 0 ) { if ( temp . left == null ) { temp . left = node ; size ++; return ; } else { temp = temp . left ; } } else { if ( temp . right == null ) { temp . right = node ; szie ++; return ; } else { temp = temp . right ; } } } } }","title":"1.2.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#122-recursion","text":"Java\u7248 public void add ( E e ) { if ( root == null ) { root = new Node ( e ); size ++; } else { add ( root , e ); } } private void add ( Node node , E e ) { if ( e . equals ( node . e )) { return ; } else if ( e . compareTo ( node . e ) < 0 && node . left == null ) { node . left = new Node ( e ); size ++; return ; } else if ( e . compareTo ( node . e ) > 0 && node . right == null ) { node . right = new Node ( e ); size ++; return ; } if ( e . compareTo ( node . e ) < 0 ) { add ( node . left , e ); } else { add ( node . right , e ); } }","title":"1.2.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#123-optimize-and-refactor-recursion-method","text":"Java\u7248 // recurse method optimization and refactor public void add ( E e ) { root = add ( root , e ); } //return the root node after add a new node private Node add ( Node node , E e ) { if ( node == null ) { size ++; return new Node ( e ); } if ( e . compareTo ( node . e ) < 0 ) { node . left = add ( node . left , e ); } else if ( e . compareTo ( node . e ) > 0 ) { node . right = add ( node . right , e ); } return node ; }","title":"1.2.3 \u9012\u5f52\u5b9e\u73b0\uff08optimize and refactor recursion method\uff09"},{"location":"BinaryTree/binarySearchTree/#13-search-method","text":"","title":"1.3 search method"},{"location":"BinaryTree/binarySearchTree/#131-not-recursion","text":"Java\u7248 public boolean contains ( E e ) { Node temp = root ; while ( temp != null ) { if ( e . compareTo ( temp . e ) == 0 ) { return true ; } else if ( e . compareTo ( temp . e ) < 0 ) { temp = temp . left ; } else { temp = temp . right ; } } return false ; }","title":"1.3.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#132-recursion","text":"Java\u7248 public boolean contains ( E e ) { return contains ( root , e ); } private boolean contains ( Node node , E e ) { if ( node == null ) { return false ; } if ( e . compareTo ( node . e ) < 0 ) { return contains ( node . left , e ); } else if ( e . compareTo ( node . e ) == 0 ) { return true ; } else { return contains ( node . right , e ); } }","title":"1.3.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#14-traversal-method","text":"","title":"1.4 traversal method"},{"location":"BinaryTree/binarySearchTree/#141-not-recursion","text":"Stack\u5b9e\u73b0preOrder public void preOrder ( Node node ) { if ( node == null ) { return ; } Stack < Node > stack = new Stack <>(); stack . push ( node ); while (! stack . isEmpty ()) { Node cur = stack . pop (); System . out . println ( cur . e ); if ( cur . right != null ) { stack . push ( cur . right ); } if ( cur . left != null ) { stack . push ( cur . left ); } } } Queue\u5b9e\u73b0levelOrder public void levelOrder () { if ( root == null ) { return ; } Queue < Node > q = new LinkedList <>(); q . add ( root ); while (! q . isEmpty ()) { Node cur = q . remove (); System . out . println ( cur . e ); if ( cur . left != null ) { q . add ( cur . left ); } if ( cur . right != null ) { q . add ( cur . right ); } } }","title":"1.4.1 \u975e\u9012\u5f52\u5b9e\u73b0\uff08not recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#142-recursion","text":"Java\u7248 public void preOrder ( Node node ) { if ( node == null ) { return ; } System . out . println ( node . e ); preOrder ( node . left ); preOrder ( node . right ); } public void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ); System . out . println ( node . e ); inOrder ( node . right ); } public void postOrder ( Node node ) { if ( node == null ) { return ; } postOrder ( node . left ); postOrder ( node . right ); System . out . println ( node . e ); }","title":"1.4.2 \u9012\u5f52\u5b9e\u73b0\uff08recursion\uff09"},{"location":"BinaryTree/binarySearchTree/#15","text":"Java\u7248 public int getHeight ( Node node ) { if ( node == null ) { return 0 ; } int leftHeight = getHeight ( node . left ); int rightHeight = getHeight ( node . right ); return 1 + Math . max ( leftHeight , rightHeight ); } public ArrayList < E > inOrder ( Node node , ArrayList < E > list ) { if ( node == null ) { return null ; } inOrder ( node . left , list ); list . add ( node . e ); inOrder ( node . right , list ); return list ; } public boolean isBST () { ArrayList < E > list = new ArrayList <>(); list = inOrder ( root , list ); for ( int i = 1 ; i < list . size (); i ++) { if ( list . get ( i ). compareTo ( list . get ( i - 1 )) < 0 ) { return false ; } } return true ; } public boolean isBalanced () { return isBalanced ( root ); } private boolean isBalanced ( Node node ) { if ( node == null ) { return true ; } int balanceFactor = getBalanceFactor ( node ); if ( Math . abs ( balanceFactor ) > 1 ) { return false ; } return isBalanced ( node . left ) && isBalanced ( node . right ); } private int getBalanceFactor ( Node node ) { if ( node == null ) { return 0 ; } return getHeight ( node . left ) - getHeight ( node . right ); }","title":"1.5 \u5224\u65ad\u662f\u5426\u4e3a\u4e8c\u5206\u641c\u7d22\u6811\u6216\u8005\u662f\u5426\u4e3a\u5e73\u8861\u4e8c\u53c9\u6811"},{"location":"BinaryTree/binarySearchTree/#16","text":"\u5f53\u63d2\u5165\u6709\u5e8f\u8868\u65f6\uff0c\u4f1a\u9000\u5316\u6210\u4e00\u4e2a\u94fe\u8868","title":"1.6 \u4e8c\u5206\u641c\u7d22\u6811\u7684\u7f3a\u70b9"},{"location":"BinaryTree/binaryTree/","text":"\u4e8c\u53c9\u6811 \u00b6 1.\u4e8c\u53c9\u6811\u904d\u5386 \u00b6 1.1 \u524d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u6839\u7ed3\u70b9->\u5de6\u5b50\u6811->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.2 \u4e2d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u6839\u7ed3\u70b9->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.3 \u540e\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u53f3\u5b50\u6811->\u6839\u7ed3\u70b9\u7684\u987a\u5e8f\u8bbf\u95ee 2.\u524d\u5e8f\u904d\u5386\uff0c\u4e2d\u5e8f\u904d\u5386\u4e0e\u540e\u5e8f\u904d\u5386\u4e4b\u95f4\u7684\u63a8\u5bfc \u00b6 2.1 \u5df2\u77e5\u524d\u5e8f\u548c\u4e2d\u5e8f\uff1a \u4ece\u524d\u5e8f\u4e2d\u627e\u6839\u7ed3\u70b9root1 \u5728\u4e2d\u5e8f\u4e2d\u6839\u636e\u6839\u7ed3\u70b9root1\u5c06\u5176\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u4ece\u524d\u5e8f\u4e2d\u627e\u5de6\u5b50\u6811\u7684\u6839\u7ed3\u70b9root2 \u5728\u4e2d\u5e8f\u4e2d\u5c06\u5de6\u5b50\u6811\u6839\u636e\u6839\u7ed3\u70b9root2\u5c06\u5de6\u5b50\u6811\u53c8\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u5faa\u73af\u4e0a\u8ff0\u8fc7\u7a0b\uff0c\u753b\u51fa\u4e8c\u53c9\u6811\u56fe\uff0c\u518d\u5f97\u5230\u540e\u5e8f\u904d\u5386 2.2 \u5df2\u77e5\u4e2d\u5e8f\u548c\u540e\u5e8f\uff1a \u63d0\u793a\uff1a\u540e\u5e8f\u7684\u6700\u540e\u4e00\u4e2a\u4e3a\u6811\u7684\u6839\u7ed3\u70b9 2.3 \u5df2\u77e5\u524d\u5e8f\u548c\u540e\u5e8f\uff1a\u7b54\u6848\u4e0d\u552f\u4e00 3.\u4e8c\u53c9\u6811\u7684\u6027\u8d28 \u00b6 \u5728\u4e8c\u53c9\u6811\u7684\u7b2ci\u5c42\u4e0a\u6700\u591a\u67092(i-1)\u4e2a\u7ed3\u70b9 \u4e8c\u53c9\u6811\u4e2d\u5982\u679c\u6df1\u5ea6\u4e3ak(\u6709k\u5c42),\u90a3\u4e48\u6700\u591a\u67092^k - 1\u4e2a\u7ed3\u70b9 4.\u4e8c\u53c9\u6811\u7684\u5f62\u6001 \u00b6 4.1 \u5b8c\u7f8e\u4e8c\u53c9\u6811(\u6ee1\u4e8c\u53c9\u6811 Perfect Binary Tree, BST) \u9ad8\u5ea6\u4e3ak\u7684\u4e8c\u53c9\u6811\u67092^k - 1\u4e2a\u7ed3\u70b9 4.2 \u5b8c\u5168\u4e8c\u53c9\u6811(Complete Binary Tree, CBT) \u4ece\u6839\u7ed3\u70b9\u5230\u5012\u6570\u7b2c\u4e8c\u5c42\u6ee1\u8db3\u5b8c\u7f8e\u4e8c\u53c9\u6811\uff0c\u6700\u540e\u4e00\u5c42\u53ef\u4ee5\u4e0d\u5b8c\u5168\u586b\u5145\uff0c\u5176\u53f6\u5b50\u7ed3\u70b9\u90fd\u9760\u5de6\u5bf9\u9f50 \u53f6\u5b50\u7ed3\u70b9\u7684\u6700\u5927\u6df1\u5ea6\u4e0e\u6700\u5c0f\u6df1\u5ea6\u5dee\u4e0d\u8d85\u8fc71 4.3 \u5b8c\u6ee1\u4e8c\u53c9\u6811(Full Binary Tree, FBT) \u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f2 4.4 \u4e09\u8005\u7684\u6bd4\u8f83 4.5 \u5e73\u8861\u4e8c\u53c9\u6811(Balanced Binary Tree) \u4efb\u610f\u7ed3\u70b9\u7684\u5de6\u5b50\u6811\u4e0e\u53f3\u5b50\u6811\u9ad8\u5ea6\u5dee\u4e0d\u8d85\u8fc71","title":"1. binaryTree"},{"location":"BinaryTree/binaryTree/#_1","text":"","title":"\u4e8c\u53c9\u6811"},{"location":"BinaryTree/binaryTree/#1","text":"1.1 \u524d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u6839\u7ed3\u70b9->\u5de6\u5b50\u6811->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.2 \u4e2d\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u6839\u7ed3\u70b9->\u53f3\u5b50\u6811\u7684\u987a\u5e8f\u8bbf\u95ee 1.3 \u540e\u5e8f\u904d\u5386\uff1a\u6309\u7167\u5de6\u5b50\u6811->\u53f3\u5b50\u6811->\u6839\u7ed3\u70b9\u7684\u987a\u5e8f\u8bbf\u95ee","title":"1.\u4e8c\u53c9\u6811\u904d\u5386"},{"location":"BinaryTree/binaryTree/#2","text":"2.1 \u5df2\u77e5\u524d\u5e8f\u548c\u4e2d\u5e8f\uff1a \u4ece\u524d\u5e8f\u4e2d\u627e\u6839\u7ed3\u70b9root1 \u5728\u4e2d\u5e8f\u4e2d\u6839\u636e\u6839\u7ed3\u70b9root1\u5c06\u5176\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u4ece\u524d\u5e8f\u4e2d\u627e\u5de6\u5b50\u6811\u7684\u6839\u7ed3\u70b9root2 \u5728\u4e2d\u5e8f\u4e2d\u5c06\u5de6\u5b50\u6811\u6839\u636e\u6839\u7ed3\u70b9root2\u5c06\u5de6\u5b50\u6811\u53c8\u5206\u4e3a\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811 \u5faa\u73af\u4e0a\u8ff0\u8fc7\u7a0b\uff0c\u753b\u51fa\u4e8c\u53c9\u6811\u56fe\uff0c\u518d\u5f97\u5230\u540e\u5e8f\u904d\u5386 2.2 \u5df2\u77e5\u4e2d\u5e8f\u548c\u540e\u5e8f\uff1a \u63d0\u793a\uff1a\u540e\u5e8f\u7684\u6700\u540e\u4e00\u4e2a\u4e3a\u6811\u7684\u6839\u7ed3\u70b9 2.3 \u5df2\u77e5\u524d\u5e8f\u548c\u540e\u5e8f\uff1a\u7b54\u6848\u4e0d\u552f\u4e00","title":"2.\u524d\u5e8f\u904d\u5386\uff0c\u4e2d\u5e8f\u904d\u5386\u4e0e\u540e\u5e8f\u904d\u5386\u4e4b\u95f4\u7684\u63a8\u5bfc"},{"location":"BinaryTree/binaryTree/#3","text":"\u5728\u4e8c\u53c9\u6811\u7684\u7b2ci\u5c42\u4e0a\u6700\u591a\u67092(i-1)\u4e2a\u7ed3\u70b9 \u4e8c\u53c9\u6811\u4e2d\u5982\u679c\u6df1\u5ea6\u4e3ak(\u6709k\u5c42),\u90a3\u4e48\u6700\u591a\u67092^k - 1\u4e2a\u7ed3\u70b9","title":"3.\u4e8c\u53c9\u6811\u7684\u6027\u8d28"},{"location":"BinaryTree/binaryTree/#4","text":"4.1 \u5b8c\u7f8e\u4e8c\u53c9\u6811(\u6ee1\u4e8c\u53c9\u6811 Perfect Binary Tree, BST) \u9ad8\u5ea6\u4e3ak\u7684\u4e8c\u53c9\u6811\u67092^k - 1\u4e2a\u7ed3\u70b9 4.2 \u5b8c\u5168\u4e8c\u53c9\u6811(Complete Binary Tree, CBT) \u4ece\u6839\u7ed3\u70b9\u5230\u5012\u6570\u7b2c\u4e8c\u5c42\u6ee1\u8db3\u5b8c\u7f8e\u4e8c\u53c9\u6811\uff0c\u6700\u540e\u4e00\u5c42\u53ef\u4ee5\u4e0d\u5b8c\u5168\u586b\u5145\uff0c\u5176\u53f6\u5b50\u7ed3\u70b9\u90fd\u9760\u5de6\u5bf9\u9f50 \u53f6\u5b50\u7ed3\u70b9\u7684\u6700\u5927\u6df1\u5ea6\u4e0e\u6700\u5c0f\u6df1\u5ea6\u5dee\u4e0d\u8d85\u8fc71 4.3 \u5b8c\u6ee1\u4e8c\u53c9\u6811(Full Binary Tree, FBT) \u6240\u6709\u975e\u53f6\u5b50\u7ed3\u70b9\u7684\u5ea6\u90fd\u662f2 4.4 \u4e09\u8005\u7684\u6bd4\u8f83 4.5 \u5e73\u8861\u4e8c\u53c9\u6811(Balanced Binary Tree) \u4efb\u610f\u7ed3\u70b9\u7684\u5de6\u5b50\u6811\u4e0e\u53f3\u5b50\u6811\u9ad8\u5ea6\u5dee\u4e0d\u8d85\u8fc71","title":"4.\u4e8c\u53c9\u6811\u7684\u5f62\u6001"},{"location":"BinaryTree/maxHeap/","text":"maxHeap \u00b6 \u4e8c\u53c9\u5806(\u501f\u52a9\u5b8c\u5168\u4e8c\u53c9\u6811) \u00b6 \u4e8c\u53c9\u5806\u7684\u7279\u70b9 1\uff0e\u7236\u7ed3\u70b9\u7684\u503c\u603b\u662f\u5927\u4e8e\u6216\u7b49\u4e8e\uff08\u5c0f\u4e8e\u6216\u7b49\u4e8e\uff09\u4efb\u4f55\u4e00\u4e2a\u5b50\u7ed3\u70b9\u7684\u503c\u3002 2\uff0e\u6bcf\u4e2a\u7ed3\u70b9\u7684\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811\u90fd\u662f\u4e00\u4e2a\u4e8c\u53c9\u5806\uff08\u90fd\u662f\u6700\u5927\u5806\u6216\u6700\u5c0f\u5806\uff09\u3002 \u6700\u5927\u5806\u5b9e\u73b0 \u00b6 \u6700\u5927\u5806\u4e2d\u7236\u7ed3\u70b9\u4e0e\u5de6\u5b69\u5b50\u7ed3\u70b9\u548c\u53f3\u5b69\u5b50\u7ed3\u70b9\u8ba1\u7b97\uff0c\u53ef\u4ee5\u501f\u52a9\u6570\u7ec4\u5b9e\u73b0\u6700\u5927\u5806 parent(i) = (i - 1) / 2 leftChild(i) = 2 * i + 1 rightChild(i) = 2 * i + 2 shitUp\u4e0eshitDown\u64cd\u4f5c \u00b6 shitUp(\u4e0a\u6d6e):\u4e0d\u65ad\u4e0e\u7236\u7ed3\u70b9\u6bd4\u8f83\uff0c\u5f53\u7236\u7ed3\u70b9\u5c0f\u4e8e\u8be5\u7ed3\u70b9\u65f6\uff0c\u4ea4\u6362\u4f4d\u7f6e shitDown(\u4e0b\u6c89):\u4e0d\u65ad\u4e0e\u5de6\u5b69\u5b50\u7ed3\u70b9\u4e0e\u53f3\u5b69\u5b50\u7ed3\u70b9\u4e2d\u7684\u8f83\u5927\u503c\u6bd4\u8f83\uff0c\u5f53\u8be5\u7ed3\u70b9\u5c0f\u4e8e\u5b69\u5b50\u7ed3\u70b9\u65f6\uff0c\u4ea4\u6362\u4f4d\u7f6e heapify\u64cd\u4f5c(\u65f6\u95f4\u590d\u6742\u5ea6O(n)) \u00b6 \u5c06\u4efb\u610f\u6570\u7ec4\u6574\u7406\u6210\u5806\u7684\u5f62\u72b6 Java \u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u5f00\u59cb\u6267\u884cshitDown()\u64cd\u4f5c\uff0c\u5e76\u4e0d\u65ad\u5411\u524d\u904d\u5386\u5230\u5806\u9876 public MaxHeap ( E [] arr ) { data = arr ; size = arr . length ; for ( int i = parent ( arr . length - 1 ); i >= 0 ; i --) { shitDown ( i ); } } \u6574\u4f53\u4ee3\u7801\u5b9e\u73b0 \u00b6 Java\u7248\u672c public class MaxHeap < E extends Comparable < E >> { private E [] data ; private int size ; @SuppressWarnings ( \"unchecked\" ) public MaxHeap ( int capacity ) { data = ( E []) new Comparable [ capacity ]; size = 0 ; } public MaxHeap () { this ( 10 ); } public MaxHeap ( E [] arr ) { data = arr ; size = arr . length ; for ( int i = parent ( arr . length - 1 ); i >= 0 ; i --) { shitDown ( i ); } } public int size () { return size ; } public int getCapacity () { return data . length ; } public boolean isEmpty () { return size == 0 ; } private int parent ( int index ) { if ( index == 0 ) { throw new IllegalArgumentException ( \"index-0 doesn't have parent.\" ); } return ( index - 1 ) / 2 ; } private int leftChild ( int index ) { return index * 2 + 1 ; } private int rightChild ( int index ) { return index * 2 + 2 ; } public void add ( E e ) { if ( size == data . length ) { resize ( data . length * 2 ); } data [ size ] = e ; size ++; shitUp ( size () - 1 ); } public E findMax () { if ( size == 0 ) { throw new IllegalArgumentException ( \"MaxHeap is empty\" ); } return data [ 0 ]; } public E extractMax () { E ret = findMax (); swap ( 0 , size - 1 ); data [ size - 1 ] = null ; size --; if ( size == data . length / 4 && data . length / 2 != 0 ) { resize ( data . length / 2 ); } shitDown ( 0 ); return ret ; } private void shitUp ( int index ) { while ( index > 0 && data [ parent ( index )]. compareTo ( data [ index ]) < 0 ) { swap ( index , parent ( index )); index = parent ( index ); } } private void shitDown ( int index ) { while ( leftChild ( index ) < size ) { int j = leftChild ( index ); if ( j + 1 < size && data [ j + 1 ]. compareTo ( data [ j ]) > 0 ) { j = rightChild ( index ); } if ( data [ index ]. compareTo ( data [ j ]) >= 0 ) { break ; } swap ( index , j ); index = j ; } } @SuppressWarnings ( \"unchecked\" ) private void resize ( int newCapacity ) { E [] newData = ( E []) new Comparable [ newCapacity ]; for ( int i = 0 ; i < size ; i ++) { newData [ i ] = data [ i ]; } data = newData ; } private void swap ( int i , int j ) { if ( i < 0 || i >= size || j < 0 || j >= size ) { throw new IllegalArgumentException ( \"Index is illegal\" ); } E temp = data [ i ]; data [ i ] = data [ j ]; data [ j ] = temp ; } }","title":"2. maxHeap"},{"location":"BinaryTree/maxHeap/#maxheap","text":"","title":"maxHeap"},{"location":"BinaryTree/maxHeap/#_1","text":"\u4e8c\u53c9\u5806\u7684\u7279\u70b9 1\uff0e\u7236\u7ed3\u70b9\u7684\u503c\u603b\u662f\u5927\u4e8e\u6216\u7b49\u4e8e\uff08\u5c0f\u4e8e\u6216\u7b49\u4e8e\uff09\u4efb\u4f55\u4e00\u4e2a\u5b50\u7ed3\u70b9\u7684\u503c\u3002 2\uff0e\u6bcf\u4e2a\u7ed3\u70b9\u7684\u5de6\u5b50\u6811\u548c\u53f3\u5b50\u6811\u90fd\u662f\u4e00\u4e2a\u4e8c\u53c9\u5806\uff08\u90fd\u662f\u6700\u5927\u5806\u6216\u6700\u5c0f\u5806\uff09\u3002","title":"\u4e8c\u53c9\u5806(\u501f\u52a9\u5b8c\u5168\u4e8c\u53c9\u6811)"},{"location":"BinaryTree/maxHeap/#_2","text":"\u6700\u5927\u5806\u4e2d\u7236\u7ed3\u70b9\u4e0e\u5de6\u5b69\u5b50\u7ed3\u70b9\u548c\u53f3\u5b69\u5b50\u7ed3\u70b9\u8ba1\u7b97\uff0c\u53ef\u4ee5\u501f\u52a9\u6570\u7ec4\u5b9e\u73b0\u6700\u5927\u5806 parent(i) = (i - 1) / 2 leftChild(i) = 2 * i + 1 rightChild(i) = 2 * i + 2","title":"\u6700\u5927\u5806\u5b9e\u73b0"},{"location":"BinaryTree/maxHeap/#shitupshitdown","text":"shitUp(\u4e0a\u6d6e):\u4e0d\u65ad\u4e0e\u7236\u7ed3\u70b9\u6bd4\u8f83\uff0c\u5f53\u7236\u7ed3\u70b9\u5c0f\u4e8e\u8be5\u7ed3\u70b9\u65f6\uff0c\u4ea4\u6362\u4f4d\u7f6e shitDown(\u4e0b\u6c89):\u4e0d\u65ad\u4e0e\u5de6\u5b69\u5b50\u7ed3\u70b9\u4e0e\u53f3\u5b69\u5b50\u7ed3\u70b9\u4e2d\u7684\u8f83\u5927\u503c\u6bd4\u8f83\uff0c\u5f53\u8be5\u7ed3\u70b9\u5c0f\u4e8e\u5b69\u5b50\u7ed3\u70b9\u65f6\uff0c\u4ea4\u6362\u4f4d\u7f6e","title":"shitUp\u4e0eshitDown\u64cd\u4f5c"},{"location":"BinaryTree/maxHeap/#heapifyon","text":"\u5c06\u4efb\u610f\u6570\u7ec4\u6574\u7406\u6210\u5806\u7684\u5f62\u72b6 Java \u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u5f00\u59cb\u6267\u884cshitDown()\u64cd\u4f5c\uff0c\u5e76\u4e0d\u65ad\u5411\u524d\u904d\u5386\u5230\u5806\u9876 public MaxHeap ( E [] arr ) { data = arr ; size = arr . length ; for ( int i = parent ( arr . length - 1 ); i >= 0 ; i --) { shitDown ( i ); } }","title":"heapify\u64cd\u4f5c(\u65f6\u95f4\u590d\u6742\u5ea6O(n))"},{"location":"BinaryTree/maxHeap/#_3","text":"Java\u7248\u672c public class MaxHeap < E extends Comparable < E >> { private E [] data ; private int size ; @SuppressWarnings ( \"unchecked\" ) public MaxHeap ( int capacity ) { data = ( E []) new Comparable [ capacity ]; size = 0 ; } public MaxHeap () { this ( 10 ); } public MaxHeap ( E [] arr ) { data = arr ; size = arr . length ; for ( int i = parent ( arr . length - 1 ); i >= 0 ; i --) { shitDown ( i ); } } public int size () { return size ; } public int getCapacity () { return data . length ; } public boolean isEmpty () { return size == 0 ; } private int parent ( int index ) { if ( index == 0 ) { throw new IllegalArgumentException ( \"index-0 doesn't have parent.\" ); } return ( index - 1 ) / 2 ; } private int leftChild ( int index ) { return index * 2 + 1 ; } private int rightChild ( int index ) { return index * 2 + 2 ; } public void add ( E e ) { if ( size == data . length ) { resize ( data . length * 2 ); } data [ size ] = e ; size ++; shitUp ( size () - 1 ); } public E findMax () { if ( size == 0 ) { throw new IllegalArgumentException ( \"MaxHeap is empty\" ); } return data [ 0 ]; } public E extractMax () { E ret = findMax (); swap ( 0 , size - 1 ); data [ size - 1 ] = null ; size --; if ( size == data . length / 4 && data . length / 2 != 0 ) { resize ( data . length / 2 ); } shitDown ( 0 ); return ret ; } private void shitUp ( int index ) { while ( index > 0 && data [ parent ( index )]. compareTo ( data [ index ]) < 0 ) { swap ( index , parent ( index )); index = parent ( index ); } } private void shitDown ( int index ) { while ( leftChild ( index ) < size ) { int j = leftChild ( index ); if ( j + 1 < size && data [ j + 1 ]. compareTo ( data [ j ]) > 0 ) { j = rightChild ( index ); } if ( data [ index ]. compareTo ( data [ j ]) >= 0 ) { break ; } swap ( index , j ); index = j ; } } @SuppressWarnings ( \"unchecked\" ) private void resize ( int newCapacity ) { E [] newData = ( E []) new Comparable [ newCapacity ]; for ( int i = 0 ; i < size ; i ++) { newData [ i ] = data [ i ]; } data = newData ; } private void swap ( int i , int j ) { if ( i < 0 || i >= size || j < 0 || j >= size ) { throw new IllegalArgumentException ( \"Index is illegal\" ); } E temp = data [ i ]; data [ i ] = data [ j ]; data [ j ] = temp ; } }","title":"\u6574\u4f53\u4ee3\u7801\u5b9e\u73b0"},{"location":"BinaryTree/redblackTree/","text":"Red Black Tree \u00b6 \u7ea2\u9ed1\u6811(Red Black Tree, RBT) \u00b6 \u7b49\u4ef7\u4e8e2-3\u6811(2-3\u6811\u5177\u6709\u7edd\u5bf9\u5e73\u8861\u6027)\uff0c\u5728\u6dfb\u52a0\u548c\u5220\u9664\u6027\u80fd\u4e0a\u4f18\u4e8eAVL 1.\u6240\u6709\u7ed3\u70b9\u7684\u989c\u8272\u4e0d\u662f\u7ea2\u8272\u5c31\u662f\u9ed1\u8272 2.\u6839\u7ed3\u70b9\u7684\u989c\u8272\u4e3a\u9ed1\u8272 3.\u6bcf\u4e00\u4e2a\u53f6\u5b50\u7ed3\u70b9(\u6700\u540e\u7684\u7a7a\u8282\u70b9)\u662f\u9ed1\u8272\u7684 4.\u7ea2\u8272\u7ed3\u70b9\u7684\u4e24\u4e2a\u5b69\u5b50\u90fd\u4e3a\u9ed1\u8272 5.\u4ece\u4efb\u610f\u7ed3\u70b9\u51fa\u53d1\u5230\u53f6\u5b50\u7ed3\u70b9\u7ecf\u8fc7\u7684\u9ed1\u8272\u7ed3\u70b9\u6570\u91cf\u76f8\u540c","title":"5. rbTree"},{"location":"BinaryTree/redblackTree/#red-black-tree","text":"","title":"Red Black Tree"},{"location":"BinaryTree/redblackTree/#red-black-tree-rbt","text":"\u7b49\u4ef7\u4e8e2-3\u6811(2-3\u6811\u5177\u6709\u7edd\u5bf9\u5e73\u8861\u6027)\uff0c\u5728\u6dfb\u52a0\u548c\u5220\u9664\u6027\u80fd\u4e0a\u4f18\u4e8eAVL 1.\u6240\u6709\u7ed3\u70b9\u7684\u989c\u8272\u4e0d\u662f\u7ea2\u8272\u5c31\u662f\u9ed1\u8272 2.\u6839\u7ed3\u70b9\u7684\u989c\u8272\u4e3a\u9ed1\u8272 3.\u6bcf\u4e00\u4e2a\u53f6\u5b50\u7ed3\u70b9(\u6700\u540e\u7684\u7a7a\u8282\u70b9)\u662f\u9ed1\u8272\u7684 4.\u7ea2\u8272\u7ed3\u70b9\u7684\u4e24\u4e2a\u5b69\u5b50\u90fd\u4e3a\u9ed1\u8272 5.\u4ece\u4efb\u610f\u7ed3\u70b9\u51fa\u53d1\u5230\u53f6\u5b50\u7ed3\u70b9\u7ecf\u8fc7\u7684\u9ed1\u8272\u7ed3\u70b9\u6570\u91cf\u76f8\u540c","title":"\u7ea2\u9ed1\u6811(Red Black Tree, RBT)"}]}